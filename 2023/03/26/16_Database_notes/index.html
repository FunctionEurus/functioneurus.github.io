<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>#16 数据库看书笔记 | Function&#39;s Blog</title>

    <meta name="description" content="&lt;blockquote&gt;
&lt;p&gt;因为期中之后买了书了 所以这儿就不再更新了（烂尾警告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;第一章&#34;&gt;&lt;a href=&#34;#第一章&#34; class=&#34;headerlink&#34; title=&#34;第一章&#34;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;p&gt;1.&lt;strong&gt;基于文件的方法&lt;/strong&gt;储存数据非常分散，无法适应数据量很大的情况，而且数据存在大量冗余，除浪费大量储存空间外还可能导致数据完整性遭到破坏。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;程序-数据依赖性&lt;/strong&gt;：当文件发生更改时需要修改所有受影响的程序。&lt;/p&gt;">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="zh-CN" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "#16 数据库看书笔记 | Function&#39;s Blog"  />
    <meta property="og:description" content= "&lt;blockquote&gt;
&lt;p&gt;因为期中之后买了书了 所以这儿就不再更新了（烂尾警告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;第一章&#34;&gt;&lt;a href=&#34;#第一章&#34; class=&#34;headerlink&#34; title=&#34;第一章&#34;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;p&gt;1.&lt;strong&gt;基于文件的方法&lt;/strong&gt;储存数据非常分散，无法适应数据量很大的情况，而且数据存在大量冗余，除浪费大量储存空间外还可能导致数据完整性遭到破坏。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;程序-数据依赖性&lt;/strong&gt;：当文件发生更改时需要修改所有受影响的程序。&lt;/p&gt;" />
    <meta property="og:url" content="http://blog.functioneurus.com/2023/03/26/16_Database_notes/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="Function" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;blockquote&gt;
&lt;p&gt;因为期中之后买了书了 所以这儿就不再更新了（烂尾警告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;第一章&#34;&gt;&lt;a href=&#34;#第一章&#34; class=&#34;headerlink&#34; title=&#34;第一章&#34;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;p&gt;1.&lt;strong&gt;基于文件的方法&lt;/strong&gt;储存数据非常分散，无法适应数据量很大的情况，而且数据存在大量冗余，除浪费大量储存空间外还可能导致数据完整性遭到破坏。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;程序-数据依赖性&lt;/strong&gt;：当文件发生更改时需要修改所有受影响的程序。&lt;/p&gt;" />
    <meta name="twitter:title" content="#16 数据库看书笔记 | Function&#39;s Blog"/>
    <meta name="twitter:description" content="&lt;blockquote&gt;
&lt;p&gt;因为期中之后买了书了 所以这儿就不再更新了（烂尾警告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;第一章&#34;&gt;&lt;a href=&#34;#第一章&#34; class=&#34;headerlink&#34; title=&#34;第一章&#34;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;p&gt;1.&lt;strong&gt;基于文件的方法&lt;/strong&gt;储存数据非常分散，无法适应数据量很大的情况，而且数据存在大量冗余，除浪费大量储存空间外还可能导致数据完整性遭到破坏。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;程序-数据依赖性&lt;/strong&gt;：当文件发生更改时需要修改所有受影响的程序。&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;blockquote&gt;
&lt;p&gt;因为期中之后买了书了 所以这儿就不再更新了（烂尾警告&lt;/p&gt;
&lt;/blockquote&gt;
&lt;h4 id=&#34;第一章&#34;&gt;&lt;a href=&#34;#第一章&#34; class=&#34;headerlink&#34; title=&#34;第一章&#34;&gt;&lt;/a&gt;第一章&lt;/h4&gt;&lt;p&gt;1.&lt;strong&gt;基于文件的方法&lt;/strong&gt;储存数据非常分散，无法适应数据量很大的情况，而且数据存在大量冗余，除浪费大量储存空间外还可能导致数据完整性遭到破坏。&lt;/p&gt;
&lt;p&gt;2.&lt;strong&gt;程序-数据依赖性&lt;/strong&gt;：当文件发生更改时需要修改所有受影响的程序。&lt;/p&gt;",
            "author": { "@type": "Person", "name": "Function" },
            "@type": "BlogPosting",
            "url": "http://blog.functioneurus.com/2023/03/26/16_Database_notes/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "http://blog.functioneurus.comundefined"
            },
            "name": "Function"
            },
            "headline": "#16 数据库看书笔记 | Function&#39;s Blog",
            "datePublished": "2023-03-26T09:00:34.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "http://blog.functioneurus.com/2023/03/26/16_Database_notes/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1651727875408.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1651727875408.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">Function&#39;s Blog</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-cliiug7lx000d30co80e644sw" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      #16 数据库看书笔记
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2023-03-26T09:00:34.000Z" itemprop="datePublished">2023-03-26</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/DB/" rel="tag">DB</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <blockquote>
<p>因为期中之后买了书了 所以这儿就不再更新了（烂尾警告</p>
</blockquote>
<h4 id="第一章"><a href="#第一章" class="headerlink" title="第一章"></a>第一章</h4><p>1.<strong>基于文件的方法</strong>储存数据非常分散，无法适应数据量很大的情况，而且数据存在大量冗余，除浪费大量储存空间外还可能导致数据完整性遭到破坏。</p>
<p>2.<strong>程序-数据依赖性</strong>：当文件发生更改时需要修改所有受影响的程序。</p>
<span id="more"></span>

<p>3.上面列出的基于文件方法的种种局限性可以归结为两个原因：(1) 数据的定义被嵌入到应用程序中,而不是分开和独立地存储。(2) 除了应用程序规定之外的那些数据访问和操作无法得到控制。</p>
<p>4.数据库是一个含有<strong>大量数据</strong>的、可能被许多部门和用户<strong>共享</strong>的大数据集。所有的数据项都被集中起来，具有很少量的数据冗余。数据库中不仅含有组织的运行数据，而且还含有<strong>对这些数据的描述</strong>。由于这个原因，数据库有时也被定义为一组集成记录的自描述的集。数据的描述称为系统目录(也称为数据字典或元数据———数据的数据)。</p>
<p>5.<strong>实体</strong>：组织中一个独立的、将要在数据库中体现出来的对象（人、地点、东西、概念或者事件）。</p>
<p>6.<strong>属性</strong>：描述我们想要记录的对象的某一方面的特性</p>
<p>7.**数据库管理系统(DBMS)**：</p>
<ul>
<li>允许用户使用**数据定义语言(DDL)**定义数据库</li>
<li>允许用户使用<strong>数据操作语言(DML)<strong>在数据库中插入、更新、删除和检索数据 -&gt; DML提供一个对数据进行一般查询的机制，称为</strong>查询语言</strong>，最常见的是<strong>结构化查询语言(SQL)</strong> -&gt; 4GL</li>
<li>提供一个安全、完整、并发控制、恢复控制的系统和一个用户可访问的目录</li>
</ul>
<p>8.<strong>数据库应用系统</strong>：通过向DBMS提出合适的请求（通常是一个SQL语句）而与数据库交互作用的计算机程序</p>
<p>9.<strong>视图</strong>：</p>
<ul>
<li>提供保密机制，将一些用户不能查看的数据排除在外</li>
<li>提供了一个自定义数据库外观的机制（而不改变源数据）</li>
<li>当基本数据库已经被改变时（如添加或删除数据项），视图仍可以提供与原来一致的、似乎未变化的数据库结构</li>
</ul>
<p>10.<strong>DBMS环境的组成部分</strong>：</p>
<ul>
<li>硬件（机器）：个人计算机、大型机甚至多台计算机组成的网络（<strong>客户-服务器体系结构</strong>：后台是服务器，前台是客户机）</li>
<li>软件（机器）：包含DBMS软件本身以及应用程序与操作系统，若DBMS是在网络中使用的，则还包括网络软件</li>
<li>数据（桥）：是DBMS环境中最重要的部分。数据库同时包含操作数据和元数据（<strong>关于数据的数据</strong>）。数据库结构称为<strong>模式（schema）</strong>，模式中包含文件（<strong>表</strong>），表中含有字段（描述每个实体性质的<strong>属性</strong>），以及实体之间的<strong>联系</strong>。元数据则被组织到系统目录中</li>
<li>过程（人）（规程）：对数据库的设计和使用进行控制的一组命令和规则</li>
<li>人（人）</li>
</ul>
<p>11.<strong>数据管理员（DA）</strong>&#x2F;<strong>数据库管理员（DBA）</strong>&#x2F;<strong>逻辑&#x2F;物理数据库设计人员</strong>&#x2F;<strong>应用开发人员</strong>&#x2F;<strong>终端用户</strong></p>
<p>12.数据库的发展历史</p>
<p>13.DBMS的优缺点</p>
<ul>
<li>优点：受控的数据冗余（有时为了表示实体之间的联系，重复储存某些关键数据是必要的）、数据一致性（若有冗余系统会更新该数据的所有备份）、相同数据量表示更多信息（集成后可以表示额外信息）、数据共享、增强的数据完整性（数据的有效性和一致性，通常用完整约束表达，约束指的是数据库不能违反的一致性规则）、增强的安全性（不被未经授权者访问）、强制执行标准、经济合算的规模、平衡各种需求冲突、增强的数据可访问性和响应性、提高的生产率、通过数据独立性增强可维护性、提高的并发性、增强的备份和恢复服务</li>
<li>缺点：复杂性高、（占用内存）规模大、DBMS的费用高、需要附加的硬件费用、转化费用大、（因为通用）性能相对较低、（资源集中管理使得脆弱性增加）故障带来的影响较大</li>
</ul>
<h4 id="第二章"><a href="#第二章" class="headerlink" title="第二章"></a>第二章</h4><p>1.<strong>三层体系结构：外部层、概念层和内部层</strong>。</p>
<p>用户从外部层观察数据，DBMS和操作系统从内部层观察数据，概念层则提供内、外部层的<strong>映射</strong>和必要的<strong>独立性</strong>。</p>
<p>三层体系结构的目的是是将用户的数据库视图与数据库的物理描述分隔开：</p>
<ul>
<li>每个用户都能访问相同的数据，但可用各自定制的数据视图而不影响其他用户</li>
<li>不要钱用户直接处理数据库物理存储的细节</li>
<li>DBA能在不影响用户视图的情况下修改数据库存储结构</li>
<li>数据库的内部结构不受存储的物理变化的影响，如将数据转存到某个新的存储设备上</li>
<li>DBA能在不影响所有用户的情况下修改数据库的概念结构</li>
</ul>
<p>2.<strong>外部层</strong>：数据库的用户视图，这一层描述与每个用户相关的数据库部分</p>
<p>3.<strong>概念层</strong>：数据库的整体视图，这一层描述了哪些数据被存储在数据库中，以及这些数据之间的联系</p>
<p>4.<strong>内部层</strong>：数据库在计算机上的物理表示，这一层描述数据是如何存储在数据库中的。内部层之下是<strong>物理层</strong>，物理层可能在DBMS的指导下受操作系统的控制</p>
<p>5.对数据库的整体描述称为<strong>数据库模式</strong>，三类模式是根据三层结构所示的三个抽象层次来定义的</p>
<ul>
<li>在最高层有若干<strong>外部模式（子模式）</strong>，与不同的数据视图相对应</li>
<li>在概念层有<strong>概念模式</strong>，描述所有的实体、属性和联系及其上的完整性约束</li>
<li>在抽象的最低层有<strong>内部模式</strong>，是内部模型的完整描述</li>
</ul>
<p>DBMS负责这三类模式之间的映射：</p>
<ul>
<li><strong>概念层到内部层的映射</strong>：使DBMS能在物理存储中找出构成概念模式中逻辑记录的实际记录或记录集，以及对逻辑记录进行操作过程中应遵守的约束</li>
<li><strong>外部层到概念层的映射</strong>：允许DBMS将用户视图中的名称映射到概念模式中相应的部分</li>
</ul>
<p>6.区分数据库的描述和数据库本身是很重要的，数据库的描述是<strong>数据库模式</strong>，这是在数据库设计过程中指定的，一般不会改变，但实际的数据可以经常改变。</p>
<p>在任一时间点上，数据库中的数据构成一个<strong>数据库实例</strong>，因此许多数据库实例可以与相同的数据库模式相对应。模式有时称为数据库的<strong>内含</strong>，而实例则称为数据库的<strong>外延（或者状态）</strong>。</p>
<p>7.<strong>数据独立性</strong>：这是设立三层体系结构的一个重要目的，这意味着对较低层的修改不会对较高层造成影响。</p>
<ul>
<li><strong>逻辑数据独立性</strong>：外部模式不受概念模式（添加或删除实体、属性或者联系）的影响 -&gt; 修改只有需要知道的用户知道</li>
<li><strong>物理数据独立性</strong>：概念模式不受内部模式变化（使用不同的文件组织方式或存储结构、使用不同的存储设备、修改索引或散列算法）的影响 -&gt; 性能变坏时改变内部模式最常见的原因</li>
</ul>
<p>8.<strong>数据库语言</strong>：</p>
<ul>
<li><p><strong>数据定义语言（DDL）</strong>：一种供DBA或用户描述和命名应用所需实体、属性和联系及其相关的完整性约束和安全约束的语言</p>
</li>
<li><p><strong>数据操作语言（DML）</strong>：提供了一组基本操作，支持对数据库中存储数据进行各种处理操作的语言（即增删查改）</p>
<p><strong>过程化DML</strong>与<strong>非过程化DML</strong>：区别在于基本的检索机制，前者必须说明<em>如何</em>得到一个DML语句的结果，而后者只需要描述希望得到<em>什么样</em>的输出</p>
</li>
</ul>
<p>9.基于记录的逻辑数据模型：用来说明数据库的整体结构以及实现的较高层描述，主要局限性在于没有提供足够的机制以说明对数据的约束。</p>
<ul>
<li><p>关系数据模型：将数据库只看作表格 -&gt; 不适用于数据库的物理结构</p>
</li>
<li><p>网状数据模型：数据被表示成一组<strong>记录</strong>，联系被表示成<strong>络</strong>，纪录被组织成一般的图结构——记录是图的<strong>结点（段）</strong>，络是图的<strong>边</strong></p>
</li>
<li><p>层次数据模型：网状模型的一种受限形式，一个节点只能有一个父节点，即被表示成树形结构</p>
</li>
</ul>
<p>10.<strong>物理数据模型</strong>：描述数据是如何存储在计算机中的，设计记录结构、记录顺序以及访问路径等信息。</p>
<p>11.<strong>DBMS的功能</strong>：</p>
<ul>
<li>数据存储、检索和更新</li>
<li>用户可访问的目录：系统目录（元数据），存储的是“关于数据的数据”</li>
<li>事务支持：确保给定事务的所有更新操作要么远不都做完要么一个都不做</li>
<li>并发控制服务</li>
<li>恢复服务：无论数据库因何原因受到破坏时都能恢复</li>
<li>授权服务：确保只有经过授权的用户才可以访问数据库</li>
<li>支持数据通信：与通信软件集成</li>
<li>完整性服务</li>
<li>提高数据独立性的服务：是程序独立于数据库的实际结构</li>
<li>实用服务程序</li>
</ul>
<h4 id="第三章-数据库的结构与Web"><a href="#第三章-数据库的结构与Web" class="headerlink" title="第三章 数据库的结构与Web"></a>第三章 数据库的结构与Web</h4><p>1.<strong>多用户DBMS结构</strong>：</p>
<ul>
<li>远程处理：</li>
</ul>
<p>所有处理都在这台物理计算机的边界内执行，用户终端通常为“哑”终端。</p>
<ul>
<li>文件服务器：</li>
</ul>
<p>在网络上的一台计算机，其主要用途是为文档、电子表格、图像和数据库之类的计算机文件提供共享存储。</p>
<p>缺点是容易造成网络拥塞，导致性能方面的问题；每台工作站上都要求有一个DBMS的完整副本；并发、恢复和完整性控制变得相当复杂，因为可能有多个DBMS访问同一个文件。</p>
<ul>
<li>传统的两层客户-服务器结构：</li>
</ul>
<p>此方法中存在一个请求资源的客户进程和一个提供资源的服务器，但并不要求客户和服务器同处一台机器。</p>
<p>客户端和服务器之间交互的典型过程是，客户端接收用户的请求，检查语法并产生用SOL或其他某种适于应用程序逻辑的数据库语言表达的数据库请求。然后将请求消息传递给服务器，等待回答。得到回答后再将其格式化并传递给终端用户。服务器接收和处理数据库请求，并将结果回传给客户端。这个过程包括检查权限、确保完整性、维护系统目录，以及执行查询和更新操作。另外，它还提供并发和恢复控制。</p>
<p>2.<strong>三层客户-服务器结构</strong></p>
<p>由于应用程序越来越复杂，当终端用户规模不断增大后，客户端对客户计算机的配置要求随之提高，客户端的管理开销也十分巨大，影响了系统的可伸缩性。</p>
<p>由此产生了传统两层客户-服务器模型的一种新变形：<br>（1）<strong>用户界面层</strong>:运行在终端用户的计算机上(客户端)。<br>（2）<strong>业务逻辑和数据处理层</strong>:该中间层运行在服务器上，通常称为应用服务器。<br>（3）<strong>DBMS层</strong>:存储中间层所需的数据。该层运行在称为数据库服务器的单独服务器上。</p>
<p>客户端只负责处理用户交互以及一些简单的业务逻辑，核心业务逻辑现在处于单独的层上，一个应用服务器可以为多个客户端提供服务。</p>
<p>优点：</p>
<ul>
<li>降低了对硬件设备的需求</li>
<li>应用程序的维护可以集中进行（转移到了单一的应用服务器上）</li>
<li>模块化特性使得修改或替换其中一层不会影响其他层</li>
<li>核心业务逻辑与数据库功能的分离使得负载平衡更容易进行</li>
<li>三层结构更容易映射到web环境，浏览器可作为客户端，服务器可作为应用服务器。</li>
</ul>
<p>3.<strong>N层客户-服务器结构</strong>：三层结构可以进一步扩展，提供进一步的灵活性和可伸缩性 -&gt; 中间层分裂为web服务器和应用服务器。</p>
<p><strong>应用服务器</strong>：通过一组应用程序编程接口（API）将业务逻辑和业务过程暴露给其他应用使用。</p>
<p>4.<strong>分布式数据库</strong>：物理分布于计算机网络上，但逻辑相互关联的共享数据（和数据描述）的集合。<br><strong>分布式DBMS（DDBMS）</strong>：管理分布式数据库并对用户提供分布透明性的软件系统。</p>
<h4 id="第四章-关系模型"><a href="#第四章-关系模型" class="headerlink" title="第四章 关系模型"></a>第四章 关系模型</h4><p>1.在关系模型中，所有数据逻辑上被组织成<strong>关系</strong>（表）结构，关系由数据的一些命名<strong>属性</strong>（列）所组成，每个<strong>元组</strong>（行）包含每个属性的一个取值。</p>
<p>2.关系数据结构：</p>
<ul>
<li><p>关系：由行和列组成的表。</p>
</li>
<li><p>属性：关系中命名的列。</p>
</li>
<li><p><strong>域</strong>：一个或多个属性的取值集合，每个属性都必须定义一个域，不同属性的域可以相同（共用一个域）也可以不同。</p>
</li>
<li><p>元组：关系中的每一行称为元组。</p>
</li>
<li><p><strong>维数</strong>：关系所包含的属性的个数。</p>
</li>
<li><p><strong>基数</strong>：关系所包含的元组的个数。</p>
</li>
<li><p>关系数据库：具有不同关系名的规范化关系的集合。</p>
</li>
</ul>
<p>3.关系的性质：</p>
<ul>
<li>有一个关系名，同一关系模式中各关系不能重名。</li>
<li>关系中的每一个单元格都确切包含一个原子(单个)值。</li>
<li>每个属性都有一个不同的名字。</li>
<li>同一属性中的各个值都取自相同的域。</li>
<li>各元组互不相同，不存在重复元组。</li>
<li>属性的顺序并不重要。</li>
<li>理论上讲，元组的顺序也不重要(但实际上，这个顺序将影响对元组的访问效率)。</li>
</ul>
<p>4.系统关键字（<strong>键</strong>）：</p>
<ul>
<li><strong>超键</strong>：一个属性或属性集合，它能唯一地标识出关系中的每个元组。</li>
<li><strong>候选键</strong>：本身是超键，但其任意子集都不再是超键。一个关系中可能会有多个候选键，当一个键中包含多个属性时就称它为<strong>合成关键字</strong>。<br>关系R中的候选键K具有两条性质：<ul>
<li>唯一性：$R$中的每个元组在$K$上的值都可以唯一地表示该元组。</li>
<li>不可约性：$K$中的任一真子集都不具备唯一性。</li>
</ul>
</li>
<li><strong>主键</strong>：被选用于唯一标识关系中各元组的候选键。没有被选为主键的候选键被称为<strong>可替换键</strong>。</li>
<li><strong>外键</strong>：当一个关系中的某个属性或属性集合与另一个关系（也可能就是自己）的候选键匹配时，就称这个属性或属性集合为外键。<br>当一个属性出现在两个关系中时，它往往表示这两个关系中对应元组之间的某种联系。</li>
</ul>
<p>5.<strong>空</strong>：代表对一个元组当前取值还不知道或是不可用的属性值。</p>
<p>6.<strong>完整性约束</strong>：域约束、实体完整性、引用完整性、多样性和一般性约束。</p>
<ul>
<li><strong>实体完整性</strong>：在基本关系中，主键的属性值不可为空。</li>
<li><strong>引用完整性</strong>：若在关系中存在某个外键，则它的值要么与主关系中某各元组的候选键取值相等，要么全部为空。</li>
<li><strong>一般性约束</strong>：由数据库用户或数据库管理员所指定的附加规则。</li>
</ul>
<p>7.<strong>视图</strong>：它不完全是用户所见到的外部模型，它指的是<strong>虚关系</strong>或<strong>导出关系</strong>，即无需单独存在，必要时可从一或多个基本关系中动态地导出的结果。</p>
<p><strong>基本关系</strong>：与概念模式中一个实体相对应的具名关系，它的元组都存储在数据库的物理结构中。<br>因此，一个外部模型可以由基本关系和基本关系所导出的视图共同组成。</p>
<p>8.视图的目的：灵活的安全性。</p>
<p>9.视图的更新：</p>
<ul>
<li>如果视图由一个基本关系的简单查询生成，而且它还包含了基本关系中的主关键字或是候选关键字，则可以通过这个视图进行更新操作。</li>
<li>不允许对涉及多个基本关系的视图进行更新。</li>
<li>如果视图的生成中涉及聚集或是分组操作，则不允许通过这个视图进行更新。</li>
</ul>
<h4 id="第五章-关系代数与关系演算"><a href="#第五章-关系代数与关系演算" class="headerlink" title="第五章 关系代数与关系演算"></a>第五章 关系代数与关系演算</h4><p>1.<strong>关系完备性</strong>：若一种语言可以生成所有由关系盐酸推导出来的关系，就称它具有关系完备性。大多数关系查询语言都具有关系完备性。</p>
<p>2.<strong>闭包</strong>：关系在关系代数下是封闭的。</p>
<p>3.关系代数中的运算：</p>
<ul>
<li>基本运算：选择、投影、笛卡尔积、集合并、集合差。</li>
<li>扩展运算：集合交、连接、除运算。（均可由基本运算导出）</li>
</ul>
<p>另一种分类：</p>
<ul>
<li>一元运算：只对一个关系进行运算 -&gt; 选择和投影</li>
<li>二元运算：其他</li>
</ul>
<p>4.一元运算：</p>
<ul>
<li><p><strong>选择（或限制）</strong>：选择运算作用域单个关系$R$，得到一个新关系，它由$R$中满足特定条件（谓词，predicate）的元组组成。<br>$$<br>\sigma_{predicate}(R)<br>$$<br>$e.g.\sigma_{salary &gt; 10000}(Staff)$ 列出工资多余10000英镑的所有员工。</p>
<p>可以使用逻辑运算符$\wedge$（与）、$\vee$（或）、$\sim$（非）来生产更复杂的谓词。</p>
</li>
<li><p><strong>投影</strong>：投影运算作用域单个关系$R$，得到由$R$的一个垂直子集构成的新关系，该垂直子集抽取$R$中指定属性上的值并去掉了重复元组。<br>$$<br>\Pi_{a_1,…,a_n}(R)<br>$$<br>$$e.g.\Pi_{staffNo, fName, lName, salary}(Staff)$$ 产生仅显示$\text{staffNo}$, $\text{fName}$, $\text{lName}$和$\text{salary}$信息的员工工资列表，并以指定的顺序排列这些属性。</p>
</li>
</ul>
<p>5.集合运算（二元运算）：</p>
<ul>
<li><p><strong>并</strong>：两个关系$R$和$S$的并，定义了一个包含$R$、$S$中所有不同元组的新关系。$R$和$S$必须具有并相容性。</p>
<p><strong>并相容性</strong>：两个关系的模式完全匹配，即它们有着同样多的属性，并且对应属性由相同的域。<br>$$<br>R\cup S<br>$$<br>$e.g.\Pi_{city}(Branch) \cup \Pi_{city}(PropertyForRent)$ 列出驻有分公司或存在待租房产的城市的清单。</p>
</li>
<li><p><strong>集合差</strong>：定义了一个新的关系，它由所有属于$R$但不属于$S$ 的元组构成。$R$和$S$也必须具有并相容性。<br>$$<br>R-S<br>$$<br>$e.g.\Pi_{city}(Branch) - \Pi_{city}(PropertyForRent)$ 列出有分公司但无待租房产的城市清单。</p>
</li>
<li><p><strong>交</strong>：定义了一个由既属于$R$又属于$S$中的元组构成的关系。$R$和$S$必须具有并相容性。<br>$$<br>R \cap S<br>$$<br>$e.g.\Pi_{city}(Branch) \cap \Pi_{city}(PropertyForRent)$ 列出既有分公司又至少存在一处待租房产的城市的清单。</p>
</li>
<li><p><strong>除</strong>：假设关系$R$定义在属性集合$A$上，关系$S$定义在属性集合$B$上，并且$B\subseteq A$（$B$是$A$的子集）。$C&#x3D;A-B$，即$C$是属于$R$但不属于$S$的属性集合。除法运算定义了属性集合$C$上的一个关系，该关系的元组与$S$中<strong>每个</strong>元组的组合都能在$R$中找到匹配元组。<br>可以将除法运算用基本运算表现为：<br>$$<br>T_1 ← \Pi_c(R)\<br>T_2 ← \Pi_c((T_1 \times S)-R)\<br>T ← T_1 -T_2<br>$$</p>
</li>
<li><p><strong>笛卡尔乘积</strong>：定义了一个关系，它是关系$R$中每个元组与关系$S$中每个元组并联的结果。</p>
<p>若一个关系有$I$个元组、$N$个属性，而另一个关系有$J$个元组、$M$个属性，则它们的笛卡尔积将会有$(I \times J)$个元组、$(N + M)$个属性。<br>$$<br>R\times S<br>$$<br>$e.g.\sigma_{Client.clientNo}&#x3D; <em>{Viewing.clientNo}(\Pi</em>{clientNo,fName,lName}(Client) \times \Pi_{clientNo,propertyNo,comment}(Viewing))$ 列出所有查看过待租房产的客户的姓名和评论。</p>
</li>
<li><p><strong>重命名运算</strong>：为表达式$E$提供了一个新的名称$S$，并将属性的名称替换成$a_1$，$\dots$，$a_2$，$a_n$。<br>$$<br>\rho_s(E)或\rho_{s(a_1,a_2,\dots,a_n)}(E)<br>$$</p>
</li>
<li><p><strong>聚集运算</strong>： 将聚集函数列表AL用于关系R，以获得在聚集列表上定义的一个关系。AL包含一个或多个（&lt;聚集函数&gt;，&lt;属性&gt;）对。<br>$$<br>\mathfrak{J}_{AL}(R)<br>$$<br>主要的聚集函数有：</p>
<ul>
<li>COUNT：返回相关联属性值的个数。</li>
<li>SUM：返回相关联属性值的总和。</li>
<li>AVG：返回相关联属性值的平均值。</li>
<li>MIN：返回相关联属性值的最小值。</li>
<li>MAX：返回相关联属性值的最大值。</li>
</ul>
</li>
<li><p>分组运算：根据分组属性$GA$对关系$R$的元组进行分组，然后使用聚集函数列表$AL$得到新关系。$AL$包含一个或多个（&lt;聚集函数&gt;，&lt;属性&gt;）对。结果关系包含分组属性$GA$，以及每个聚集函数的结果。<br>$$<br><em>{GA}\mathfrak{J}</em>{AL}(R)<br>$$</p>
</li>
</ul>
<p>6.<strong>连接运算</strong>：</p>
<ul>
<li><p><strong>$\theta$连接</strong>：$\theta$连接运算定义一个关系，它包含$R$和$S$的笛卡尔积中所有满足谓词$F$的元组。谓词$F$的格式为$R.a_i \theta S.b_i$，其中$\theta$为六个比较运算符（$&lt;,\le,&gt;,\ge,&#x3D;,\ne$）之一。<br>还可以将$\theta$连接用基本的选择运算和笛卡尔乘积运算表示为：$R\bowtie_FS&#x3D;\sigma_F(R \times S)$<br>因为$\theta$连接是基于笛卡尔积的，所以它的维数是$R$与$S$的维数之和。<br>在谓词$F$仅包含等号的情况下，$\theta$连接就变成了<strong>等接</strong>。</p>
</li>
<li><p><strong>等接</strong>：使用等接运算可以和使用笛卡尔积和选择运算得到同样的结果：$(\Pi_{clientNo,fName,lName}(Client)\bowtie_{Client.clientNo&#x3D;Viewing.clientNo}(\Pi_{clientNo,propertyNo,comment}(Viewing))$ 列出所有查看过待租房产的客户的姓名和评论。</p>
</li>
<li><p><strong>自然连接</strong>：是关系$R$和$S$在所有公共属性$x$上的等接，但在得到的结果中每个公共属性只保留一次，其余的删除。<br>$$<br>R\bowtie S<br>$$<br>自然连接运算对两个关系中所具有相同名称的属性执行等接运算，自然连接的维数等于关系$R$与$S$的维数之和减去$x$中属性的个数。</p>
</li>
<li><p><strong>左外连接</strong>：将$R$中所有的元组都保留在结果关系中，包括那些公共属性与$S$不匹配的（不满足连接条件的 ），不过，结果关系中来自$S$的所有非公共属性均取空。<br>$$<br>R⟕S<br>$$<br>类似的还有右外连接以及全外连接，全外连接保留了左、右两个关系中的所有元组，凡是、没有找到匹配元组的就在相应的属性中填入空。</p>
</li>
<li><p><strong>半连接</strong>：半连接运算定义的关系包含$R$中的这样一些元组，它们参与了$R$和$S$满足谓词$F$的连接。<br>半连接运算执行了两个关系的连接后，再将结果投影到第一个参与运算的关系的所有属性上。半连接的优点之一是可以减少必须参与连接的元组的数目。<br>可以使用投影和连接运算重写半连接运算。<br>$$<br>R\triangleright_FS&#x3D;\Pi_A(R\bowtie_FS)<br>$$<br>这实际上是一个半$\theta$连接，另外还有半等接、半自然连接等变形。</p>
</li>
</ul>
<p>7.<strong>关系演算（还没有讲）p121</strong> 应该之后也不讲了</p>
<h4 id="第六章-SQL：数据操作"><a href="#第六章-SQL：数据操作" class="headerlink" title="第六章 SQL：数据操作"></a>第六章 SQL：数据操作</h4><p>1.SQL的目标：</p>
<ul>
<li>建立数据库和关系结构</li>
<li>完成基本数据管理任务，如数据的增删改</li>
<li>完成简单或复杂的查询</li>
</ul>
<p>2.SQL是<strong>面向转换、非过程化且无格式</strong>的语言，将输入关系转换为所需的输出关系，它包括两个主要部分：</p>
<ul>
<li>数据定义语言（DDL）用于定义数据库结构和数据的访问控制。</li>
<li>数据操作语言（DML）用于检索和更新数据。</li>
</ul>
<p>3.SQL语句包括<strong>保留字</strong>和<strong>用户自定义字</strong>，不区分大小写。为增加可读性，可采用缩进和下划线。</p>
<p>4.<strong>数据操作</strong>：SELECT、INSERT、UPDATE、DELETE。</p>
<ul>
<li>SELECT：用于检索并显示一个或多个数据库表中的数据。<br>SELECT语句中子句的顺序不能改变，仅有最开始的两个字句SELECT和FROM是必须的，其余子句均为可选择的。SELECT操作是封闭的。<ul>
<li>检索所有的行（可使用DISTINCT）</li>
<li>行选择（WHERE子句）<ul>
<li>比较运算&#x2F;符合比较运算</li>
<li>范围&#x2F;集合成员测试&#x2F;模式匹配&#x2F;空作为查找条件</li>
</ul>
</li>
<li>查询结果排序（ORDER BY子句）-&gt; 单列&#x2F;多列排序</li>
</ul>
</li>
</ul>
<p>5.<strong>常量</strong>：SQL语句中使用的不变量，可以简单分为分为用引号引起来的和不用引号的。所有非数值型数据必须用单引号引起来，而所有数值型数据一定不能使用引号。</p>
<p>6.<strong>聚集函数</strong>：ISO标准定义了五个聚集函数，分别是COUNT、SUM、AVG、MIN和MAX。<br>这些函数对表中的单个列进行操作，只返回一个值。<br>*聚集函数只能用于SELECT列表和HAVING子句中，而HAVING子句又要搭配GROUP BY使用。</p>
<p>7.<strong>查询结果分组</strong>（GROUP BY子句）：对一列中的所有值进行分组查询。<br>*两个NULL值被认为是相等的。</p>
<p>8.<strong>分组约束</strong>（HAVING子句）：将分组“过滤”到查询表中。ISO要求HAVING子句所用的列名必须出现在GROUP BY子句列表中，或包括在聚集函数中。<br>*HAVING子句并不是SQL的必要部分。</p>
<p>9.<strong>子查询</strong>：将SELECT语句完全嵌套到另一个SELECT语句中，内部SELECT语句（<strong>子查询&#x2F;嵌套查询</strong>）的结果用在<strong>外部</strong>语句中以决定最后的查询结果。可以认为子查询产生一个临时表，便于外部语句访问和利用。<br>子查询的类型：</p>
<ul>
<li>标量子查询：返回单个列和单个行，即单值。</li>
<li>行子查询：返回多个列，但只有单个行。</li>
<li>表子查询：返回多个行，每行有一个或多个列。</li>
</ul>
<p>10.<strong>ANY</strong>和<strong>ALL</strong>：关键字ANY和ALL用于产生单个列的子查询。<br>若子查询前缀关键字ALL，那么仅当子查询产生的所有值都满足条件时，条件才为真。<br>若子查询前缀关键字ANY，那么子查询产生的任何一个值（一个或多个）满足条件时，条件就为真。ISO标准允许用限定词SOME代替ANY。</p>
<p>11.<strong>多表查询</strong>：要把来自多个表的列组合到结果表时，就需要用到<strong>连接</strong>操作。<br><strong>三表连接</strong>：在WHERE语句中使用…AND…即可。</p>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2023/04/01/broken_thoughts_in_APR/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          碎碎念存档_APR
        
      </div>
    </a>
  
  
    <a href="/2023/03/01/broken_thoughts_in_MAR/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">碎碎念存档_MAR</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=#16 数据库看书笔记 - Function's Blog&url=http%3A%2F%2Fblog.functioneurus.com%2F2023%2F03%2F26%2F16_Database_notes%2F">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=#16 数据库看书笔记 - Function's Blog&u=http%3A%2F%2Fblog.functioneurus.com%2F2023%2F03%2F26%2F16_Database_notes%2F">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=#16 数据库看书笔记 - Function's Blog&url=http://blog.functioneurus.com/2023/03/26/16_Database_notes/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/408/" rel="tag">408</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memo/" rel="tag">Memo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%B1%E7%BF%BB%E4%B9%A6/" rel="tag">乱翻书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E4%BA%BA/" rel="tag">同人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%9F%E8%AF%9D/" rel="tag">废话</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/06/02/broken_thoughts_in_23_JUNE/">碎碎念存档_JUNE</a>
          </li>
        
          <li>
            <a href="/2023/05/04/broken_thoughts_in_23_MAY/">碎碎念存档_MAY</a>
          </li>
        
          <li>
            <a href="/2023/04/01/broken_thoughts_in_APR/">碎碎念存档_APR</a>
          </li>
        
          <li>
            <a href="/2023/03/26/16_Database_notes/">#16 数据库看书笔记</a>
          </li>
        
          <li>
            <a href="/2023/03/01/broken_thoughts_in_MAR/">碎碎念存档_MAR</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Function&#39;s Blog &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1651727875408.js"></script>


<script src="/dist/custom.js?1651727875408.js"></script>













</body>

</html>