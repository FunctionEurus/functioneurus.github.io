<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>#4 继承与多态 | Function&#39;s Blog</title>

    <meta name="description" content="&lt;h1 id=&#34;继承&#34;&gt;&lt;a href=&#34;#继承&#34; class=&#34;headerlink&#34; title=&#34;继承&#34;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;面向对象编程的关键思想是多态性（polymorphism），使用继承可以实现多态性。&lt;/p&gt;
&lt;p&gt;通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不同的东西。&lt;/p&gt;
&lt;p&gt;派生类（derived class）能够：继承基类（base class）定义的成员，无须改变而使用那些与派生类型具体特性不相关的操作，重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。&lt;/p&gt;">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="zh-CN" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "#4 继承与多态 | Function&#39;s Blog"  />
    <meta property="og:description" content= "&lt;h1 id=&#34;继承&#34;&gt;&lt;a href=&#34;#继承&#34; class=&#34;headerlink&#34; title=&#34;继承&#34;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;面向对象编程的关键思想是多态性（polymorphism），使用继承可以实现多态性。&lt;/p&gt;
&lt;p&gt;通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不同的东西。&lt;/p&gt;
&lt;p&gt;派生类（derived class）能够：继承基类（base class）定义的成员，无须改变而使用那些与派生类型具体特性不相关的操作，重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。&lt;/p&gt;" />
    <meta property="og:url" content="http://blog.functioneurus.com/2022/05/20/4_Inheritance_and_Polymorphism/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="Function" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;h1 id=&#34;继承&#34;&gt;&lt;a href=&#34;#继承&#34; class=&#34;headerlink&#34; title=&#34;继承&#34;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;面向对象编程的关键思想是多态性（polymorphism），使用继承可以实现多态性。&lt;/p&gt;
&lt;p&gt;通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不同的东西。&lt;/p&gt;
&lt;p&gt;派生类（derived class）能够：继承基类（base class）定义的成员，无须改变而使用那些与派生类型具体特性不相关的操作，重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。&lt;/p&gt;" />
    <meta name="twitter:title" content="#4 继承与多态 | Function&#39;s Blog"/>
    <meta name="twitter:description" content="&lt;h1 id=&#34;继承&#34;&gt;&lt;a href=&#34;#继承&#34; class=&#34;headerlink&#34; title=&#34;继承&#34;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;面向对象编程的关键思想是多态性（polymorphism），使用继承可以实现多态性。&lt;/p&gt;
&lt;p&gt;通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不同的东西。&lt;/p&gt;
&lt;p&gt;派生类（derived class）能够：继承基类（base class）定义的成员，无须改变而使用那些与派生类型具体特性不相关的操作，重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;h1 id=&#34;继承&#34;&gt;&lt;a href=&#34;#继承&#34; class=&#34;headerlink&#34; title=&#34;继承&#34;&gt;&lt;/a&gt;继承&lt;/h1&gt;&lt;p&gt;面向对象编程的关键思想是多态性（polymorphism），使用继承可以实现多态性。&lt;/p&gt;
&lt;p&gt;通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不同的东西。&lt;/p&gt;
&lt;p&gt;派生类（derived class）能够：继承基类（base class）定义的成员，无须改变而使用那些与派生类型具体特性不相关的操作，重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。&lt;/p&gt;",
            "author": { "@type": "Person", "name": "Function" },
            "@type": "BlogPosting",
            "url": "http://blog.functioneurus.com/2022/05/20/4_Inheritance_and_Polymorphism/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "http://blog.functioneurus.comundefined"
            },
            "name": "Function"
            },
            "headline": "#4 继承与多态 | Function&#39;s Blog",
            "datePublished": "2022-05-20T06:32:24.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "http://blog.functioneurus.com/2022/05/20/4_Inheritance_and_Polymorphism/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1651727875408.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1651727875408.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">Function&#39;s Blog</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clj8jslku000kvwcohfe3c1hr" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      #4 继承与多态
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2022-05-20T06:32:24.000Z" itemprop="datePublished">2022-05-20</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/C/" rel="tag">C++</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <h1 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h1><p>面向对象编程的关键思想是多态性（polymorphism），使用继承可以实现多态性。</p>
<p>通过继承我们能够定义这样的类，它们对类型之间的关系建模，共享公共的东西，仅仅特化本质上不同的东西。</p>
<p>派生类（derived class）能够：继承基类（base class）定义的成员，无须改变而使用那些与派生类型具体特性不相关的操作，重定义那些与派生类型相关的成员函数，将函数特化，考虑派生类型的特性。最后，除了从基类继承的成员之外，派生类还可以定义更多的成员。</p>
<span id="more"></span>

<pre><code class="c++">//继承的语义：
is a 
</code></pre>
<h1 id="定义基类"><a href="#定义基类" class="headerlink" title="定义基类"></a>定义基类</h1><p>我们经常称因继承而相关联的类为构成了一个继承层次。其中有一个类称为根，所以其他类直接或间接继承根类。</p>
<pre><code class="c++">class EE &#123; //电子设备
    protected:
        int price; //保护的数据成员可以被派生类的成员函数访问
    public:
        void Work();
        void SetPrice(int initp);
        void GetPrice(int *oldp);
        void NVWhoAmI()   &#123;
            cout &lt;&lt; &quot;I am a EE&quot; &lt;&lt; endl;
        &#125;;
        //我是谁? 前缀NV表示非虚的意思.
        EE(void);
        ~EE(void);
&#125;;
</code></pre>
<h2 id="Protected成员"><a href="#Protected成员" class="headerlink" title="Protected成员"></a>Protected成员</h2><p>可以认为<code>protected</code>访问标号是<code>private</code>和<code>public</code>的混合：像<code>private</code>成员一样，<code>protected</code>成员不能被类的用户访问；同时也像<code>public</code>成员一样，<code>protected</code>成员可被该类的派生类访问。</p>
<p>派生类只能通过派生类对象访问其基类的<code>protected</code>成员。</p>
<h1 id="派生类"><a href="#派生类" class="headerlink" title="派生类"></a>派生类</h1><p>为了定义派生类，使用类派生列表指定基类。类派生列表指定了一个或多个基类，具有如下形式：</p>
<pre><code class="c++">class classname: access-label base-class &#123;&#125;;
</code></pre>
<p>派生类对象包含基类对象作为子对象，基类更单纯，子类更复杂。</p>
<pre><code class="c++">class MT :  public EE &#123;
    protected:
        int rent; //月租费。派生类可以有自己的数据成员和方法。price无需再进行声明.
    public:
        void Call();
        void MTSetPrice(int price);
        void MTGetPrice(int *oldp);
        //派生类成员函数可以访问基类的保护成员，这里故意加上前缀“MT”，已示区别，其实没有必要。
        MT(void);
        ~MT(void);
&#125;;
</code></pre>
<p>基类的公有的方法和数据可以通过派生类直接访问。</p>
<pre><code class="c++">MT *pmt = new MT;
pmt-&gt;NVWhoAmI ();    //结果为：I am a EE
pmt-&gt;pbvar = ……; //也可以直接访问基类的公有的数据成员：假设pbvar是EE的公共数据成员
</code></pre>
<p>类保护成员只能在派生类的成员内部访问，比如：</p>
<pre><code class="c++">void MT::MTSetPrice (int price) &#123;
    EE::price = price;   //派生类成员函数访问基类的保护数据成员
&#125;
//客户使用方法：
MT *pmt = new MT;
pmt-&gt;MTSetPrice(5); //客户调用派生类的成员函数,函数内部访问基类的保护数据成员
pmt-&gt;price = 5; //出错.不能直接访问
</code></pre>
<p>可以定义更多派生类：</p>
<pre><code class="c++">class CA :  public EE &#123; //照相机
    protected:
        int pixel;  //像素
    public:
        void  TakePhoto(int *pix);
        CA(void);
        ~CA(void);
&#125;;
</code></pre>
<pre><code class="c++">//对于以下代码:
MT *pmt = new MT;
CA *pca = new CA;
pmt-&gt;NVWhoAmI (); //派生类访问基类的公有的方法。
pca-&gt;NVWhoAmI (); //另一个派生类访问基类的公有的方法
//结果为：I am a EE和I am a EE
//结果当然是一样的.但是我们期望能得到更精细的信息
</code></pre>
<h1 id="隐藏"><a href="#隐藏" class="headerlink" title="隐藏"></a>隐藏</h1><p>为此在派生类中增加一个新函数：</p>
<pre><code class="c++">class MT :	public EE &#123;
    protected:
        int rent;
    public:
        void Call();
        void NVWhoAmI();  
        //签名虽然完全相同，但它是派生类定义的成员, 或者理解成为碰巧完全相同。当然可以再加上一个前缀MT, 但是会显得太罗嗦, C++支持如上做法. 虽然这种方式不好,但是是合法的.
        void MTSetPrice(int price);
        void MTGetPrice(int *oldp);
        MT(void);
        ~MT(void);
&#125;;
</code></pre>
<p>而其实现为：</p>
<pre><code class="c++">void MT::NVWhoAmI () &#123;
    cout &lt;&lt; &quot;I am a MT&quot; &lt;&lt; endl;
&#125;;
</code></pre>
<p>类似地对另一个类如法炮制：</p>
<pre><code class="c++">void CA::NVWhoAmI () &#123;
    cout &lt;&lt; &quot;I am a CA&quot; &lt;&lt; endl;
&#125;;
</code></pre>
<p>于是我们可以分别出不同的类对象：</p>
<pre><code class="c++">MT *pmt = new MT;
CA *pca = new CA;
pmt-&gt;NVWhoAmI ();   // I am a MT
pca-&gt;NVWhoAmI ();   // I am a CA  比刚才有进步
</code></pre>
<p>这种方法称为隐藏。</p>
<p>面对层出不穷的各种各样的电子设备，我们必须定义这些设备的对象，并分别调用<code>NVWhoAmI</code>。</p>
<pre><code class="c++">ptv-&gt;NVWhoAmI ();   // I am a Television
ppc-&gt;NVWhoAmI ();   // I am a Personal Computer.
prd-&gt;NVWhoAmI ();   // I am a Radio
//...维护困难
</code></pre>
<h1 id="一致性处理"><a href="#一致性处理" class="headerlink" title="一致性处理"></a>一致性处理</h1><p>因此，为了高效率地处理不同的子类对象，我们往往把基类指针指向子类（派生类）的对象，在直观上当然是合理的（android手机也是手机）。</p>
<p>子类对象比基类对象更“大”, 子类对象中含有一个基类的子对象 “subobject”，基类的指针将指向这个子对象。</p>
<img src="image-20220520155159946.png" alt="image-20220520155159946" style="zoom: 67%;" />

<pre><code class="c++">EE *pee[2];
pee[0] = new MT; //基类指针指向子类的对象 MT当然是一个EE
pee[1] = new CA; // CA也是一个EE
for (int i = 0; i &lt; 2; i++)
    pee[i]-&gt;NVWhoAmI (); //基类指针只能调用基类定义的成员
//这段代码解决了代码的冗余性，但是执行结果为：I am a EE和I am a EE
</code></pre>
<p>选择：要么睁大眼睛，分别使用不同的派生类指针来询问其身份（如果有10个不同的派生类，我们要写10句雷同的<code>p*-&gt;NVWhoAmI()</code> ）；要么虽然很优雅，使用基类指针通过一个循环来调用，但只能得到一个笼统的回答。</p>
<h1 id="虚函数"><a href="#虚函数" class="headerlink" title="虚函数"></a>虚函数</h1><p>我们对于效率、美观、功能的需求导致我们需要多态。虚函数是实现多态的一种方式，当然，还有别的方式。</p>
<p>我们付出了代价：相对于普通函数而言，虚表及虚表指针是额外的开销，处理不当，可能会达到不能忍受的地步，而且我们还要付出脑力的代价:-)</p>
<pre><code class="c++">//对基类作出如下改进
class EE &#123;
    protected:
        int price;
    public:
        void Work();
        void  SetPrice(int initp);
        void  GetPrice(int *oldp);
        void  NVWhoAmI();
        virtual void WhoAmI() &#123;
            cout &lt;&lt; &quot;I am a EE&quot; &lt;&lt; endl;
        &#125;;
        //虚函数关键字virtual，目的是启用动态绑定，指明成员函数为虚函数
        //成员函数默认非虚，除了构造函数之外，任意非static成员函数都可以是虚函数
        EE(void);
        ~EE(void);
&#125;;
</code></pre>
<p>派生类如下：</p>
<pre><code class="c++">class MT :	public EE &#123;
    protected:
        int rent;
    public:
        void Call();
        void NVWhoAmI();
        void WhoAmI();     //虽然没有加(也可以加.) virtual , 也是虚函数。
        MT(void);
        ~MT(void);
&#125;;

void MT::WhoAmI () &#123;
    cout &lt;&lt; &quot;I am a MT&quot; &lt;&lt; endl;   //改写(override)此虚函数
&#125;;
</code></pre>
<p>对另一个类<code>CA</code>我们也作类似处理：</p>
<pre><code class="c++">void CA::WhoAmI () &#123;
    cout &lt;&lt; &quot; I am a CA&quot; &lt;&lt; endl;
&#125;;

//此时对于以下代码：
EE *pee[2];
pee[0] = new MT;
pee[1] = new CA;
for (int i = 0; i &lt; 2; i++)
    pee[i]-&gt;WhoAmI ();           //1.一致,优雅
//结果为：
//I am a MT和I am a CA           //2.信息准确,丰富
</code></pre>
<h2 id="虚函数实现机制"><a href="#虚函数实现机制" class="headerlink" title="虚函数实现机制"></a>虚函数实现机制</h2><p>编译器为每个包含虚函数的类产生一个静态函数指针数组，即虚函数表<code>vtbl</code>，在这个类或它的基类中定义的每一个虚函数都有一个相应的函数指针，该指针指向它的实现。该类的每个实例包含一个不可见的数据成员，即虚函数指针<code>vptr</code>，这个指针被构造函数自动初始化，指向类的虚表。当客户调用虚函数的时候，编译器产生代码指向<code>vptr</code>,索引到虚表中，找到函数指针发出调用。</p>
<p>此虚表在类有了定义以后就由编译器分配了，它是与类（而不是对象）相关的静态的指针数组。类实例化为对象后，对象的虚表指针将指向此虚表。对象的虚表指针往往放在其他数据成员的前面，对象的<code>this</code>指针将指向此虚表指针。</p>
<p>虚函数的额外开销: （32位系统中）</p>
<p>类: 包含此虚函数的类（定义的或继承来的）虚表（一个函数一个表项——4字节）</p>
<p>对象: 每生成一个对象，就产生一个虚表指针（4字节）。</p>
<h2 id="纯虚函数"><a href="#纯虚函数" class="headerlink" title="纯虚函数"></a>纯虚函数</h2><p>没有实现的虚函数成为纯虚函数。包含有纯虚函数的类称为抽象类。抽象类的虚表中纯虚函数的表项为空指针。由此，一个包含纯虚函数的类是不能实例化的。否则，它的实例调用此函数该怎么办？</p>
<p>纯虚函数的意义在于规定一个方法的签名，而由其派生类去实现它。</p>
<h2 id="使用虚函数实现多态"><a href="#使用虚函数实现多态" class="headerlink" title="使用虚函数实现多态"></a>使用虚函数实现多态</h2><pre><code class="c++">EE *pee[2];
pee[0] = new MT;
pee[1] = new CA;
for (int i = 0; i &lt; 2; i++)
    pee[i]-&gt;WhoAmI ();
</code></pre>
<p>基类的指针指向不同的子类对象，这些子类对基类所定义的虚函数有不同的实现。当通过基类指针调用这些函数的时候，调用的是子类的带有个性的实现。</p>
<h2 id="对象切割（Object-slice）"><a href="#对象切割（Object-slice）" class="headerlink" title="对象切割（Object slice）"></a>对象切割（Object slice）</h2><p>当基类指针指向派生类对象时，通过基类指针调用虚函数时，编译器会找到其所指向的实际对象对虚函数的实现。</p>
<p>通过基类指针或引用间接指向派生类的对象时，多态性才起作用，使用基类对象并不能保留住派生类的类型身份。</p>
<pre><code class="c++">MT mt;
EE ee;
ee = mt; //object slice 非正常
EE *pee = &amp;mt; //正常
EE &amp;ree = mt;  //正常
ee.WhoAmI();	    //I am a EE
pee-&gt;WhoAmI ();     // I am a MT
ree.WhoAmI ();      // I am a MT
//ee=mt;进行了一次object slice，Mt被slice只剩下一半，而且WhoAmI函数还要使用mt的this指针,情况会如何?
//实际上编译器自动为EE生成了一个拷贝构造函数，这时ee是一个完全的EE对象，它调用WhoAmI时将使用自己的实现。
</code></pre>
<p>应避免使用对象切割。</p>
<h2 id="动态绑定（Late-bind）"><a href="#动态绑定（Late-bind）" class="headerlink" title="动态绑定（Late bind）"></a>动态绑定（Late bind）</h2><p>非虚函数：早绑定（编译时刻）；虚函数：晚绑定（运行时刻）。</p>
<pre><code class="c++">EE *pee;
if (Sunshine)
    pee = new CA;
else
    pee = new MT;
pee-&gt;WhoAmI();//超 我也不知道会输出啥了救命
</code></pre>
<h1 id="多重继承的虚表"><a href="#多重继承的虚表" class="headerlink" title="多重继承的虚表"></a>多重继承的虚表</h1><pre><code class="c++">// 1. 电器
class EE &#123;
    protected:
        int  price;
    public:
        virtual void Work() &#123;
            cout &lt;&lt; &quot;EE is working&quot; &lt;&lt; endl;
        &#125;;
        virtual void WhoAmI()  &#123;
            cout &lt;&lt; &quot; I am a EE&quot; &lt;&lt; endl;
        &#125;;
        EE(void);
        ~EE(void);
&#125;;

//2 手机
class MT :  public EE &#123;
    protected:
        int rent;
    public:
        void WhoAmI() &#123;
            cout &lt;&lt; “I am a MT” &lt;&lt; endl;
        &#125;; //改写
        virtual void Call() &#123;
            cout &lt;&lt; “MT is calling” &lt;&lt; endl;
        &#125;;//打电话
        MT(void);
        ~MT(void);
&#125;;

//3. 照相机
class CA :	public EE &#123;
    protected:
        int pixel;
    public:
        void Work() &#123;
            cout &lt;&lt; “CA is working” &lt;&lt; endl;
        &#125;;//这里Work也改写了,作为对比,MT没有改写它.
        void WhoAmI() &#123;
            cout &lt;&lt; “I am a CA” &lt;&lt; endl;
        &#125;;  //改写
        virtual void  TakePhoto() &#123;
            cout &lt;&lt; “CA is takephoto” &lt;&lt; endl;
        &#125;;   //照像
        CA(void);
        ~CA(void);
&#125;;

//假设现在有一款能拍照的手机
class MTCA :	public MT, public CA &#123; // 4. 能拍照的手机
    public:
        virtual void WhoAmI() &#123;
            cout &lt;&lt; &quot;I am a MTCA&quot; &lt;&lt; endl;
        &#125;;
        //继承自EE. 改写.
        virtual void Call() &#123;
            cout &lt;&lt; &quot; MTCA is calling&quot; &lt;&lt; endl;
        &#125;;
        //继承自MT 改写
        virtual void TakePhoto() &#123;
            cout &lt;&lt; &quot;MTCA is Taking Photo&quot; &lt;&lt; endl;
        &#125;;
        //继承自CA 改写
        MTCA(void);
        ~MTCA(void);
&#125;;
//虚表和虚表指针的示意图...自己画！（不是
</code></pre>
<h1 id="二义性"><a href="#二义性" class="headerlink" title="二义性"></a>二义性</h1><p><code>MTCA</code>对象中含有一个<code>MT</code>子对象和一个<code>CA</code>子对象，这两个子对象分别含有一个<code>EE</code>子对象，这两个子对象是不一样的：数据成员不一样。可能分别在它们的子类<code>MT</code>和<code>CA</code>中被赋为不同的值；函数成员不一样（非虚的和静态的都是一样的）它们的子类可能对它们的虚函数进行了不同的改写。这是两个名字相同但内容可能不同的两个对象。</p>
<h2 id="成员二义性（变量及函数）"><a href="#成员二义性（变量及函数）" class="headerlink" title="成员二义性（变量及函数）"></a>成员二义性（变量及函数）</h2><pre><code class="c++">MTCA *pmtca = new MTCA;
pmtca-&gt;WhoAmI ();  // I am a MTCA
//没有二义性。因为MTCA对其进行了改写，消除了MT和CA带来的差异性。通过MTCA指针调用WhoAmI将指向自己的实现
pmtca-&gt;Work();   // MTCA 有两个Work, 二义性, 调用不明确,编译出错  MTCA没有对Work进行覆盖,其虚表中有两项Work,分别指向MT和CA对其的实现.无法通过编译. 编译器不知道要调用哪一个.
pmtca-&gt;CA::Work(); // CA is working
//将调用CA的实现,而CA覆盖了它;
pmtca-&gt;MT::Work(); // EE is working
//将调用MT的实现,而MT没有覆盖它,直接使用EE的实现
//(类似地， pmtca-&gt;price,也有二义性。必须像pmtca-&gt;CA::price   pmtca-&gt;MT::price来使用）
</code></pre>
<h2 id="转换二义性"><a href="#转换二义性" class="headerlink" title="转换二义性"></a>转换二义性</h2><pre><code class="c++">EE *pee[3];
pee[0] = (EE *) pmtca; //存在二义性, 转换不明确,编译出错
pee[1] = (EE *)(MT *)pmtca; //转换途径1
pee[2] = (EE *)(CA *)pmtca; //转换途径2
//这种二义性正是多重遭到诸多非议的原因
</code></pre>
<h1 id="RTTI"><a href="#RTTI" class="headerlink" title="RTTI"></a>RTTI</h1><p>为了一致性，往往用基类指针指向子类对象。这样做总是安全的。甚至可以通过此指针调用到子类所改写的虚函数。即多态调用。</p>
<p>但除此之外，通过这个指针并不能做更多的工作。基类指针对子类其他独特的个性一无所知。 </p>
<p>面对一个基类指针，它可以指向各种子类对象，在行动之前,（什么行动？即下文的类型转换）需要准确地探明它指向的是什么，即<code>RTTI</code>（Run Time Type Identification）</p>
<p>如同虚函数的晚绑定，<code>RTTI</code>在编译的时刻不能进行，须在运行时进行:</p>
<pre><code class="c++">EE *pee;
if ( Sunshine)
    pee = new CA;
else
    pee = new MT;
pee-&gt;WhoAmI();      //运行时刻进行晚绑定。
</code></pre>
<p>我们之前定义的<code>WhoAmI</code>就是一个简单的<code>RTTI</code>。</p>
<p><code>MFC</code>中使用类型识别网的方法来实现<code>RTTI</code>。</p>
<p>标准C++提供了两个操作符来支持<code>RTTI</code>：<code>typeid</code>和<code>dynamic_cast</code></p>
<p><code>type_info</code>类定义如下:</p>
<pre><code class="c++">class type_info &#123;
    public:
        virtual ~type_info();
        int operator==(const type_info &amp;rhs) const;
        int operator!=(const type_info &amp;rhs) const;
        int before(const type_info &amp;rhs) const;
        const char *name() const;
        const char *raw_name() const;
    private:
        ...
&#125;;

//重载了== 和!= 以对两个类型进行比较操作
//成员函数name输出类型的字符串型的名字.
</code></pre>
<p><code>typeid</code>的典型用法：</p>
<pre><code class="c++">MT *pm = new MT;
EE *pe = pm;
cout &lt;&lt; typeid( pe ).name() &lt;&lt; endl;    //class EE*     变量是EE*类型
cout &lt;&lt; typeid( *pe ).name() &lt;&lt; endl;  //class MT     指向的是MT对象
cout &lt;&lt; typeid( pm ).name() &lt;&lt; endl;   // class MT *
cout &lt;&lt; typeid( *pm ).name() &lt;&lt; endl;  // class MT
//用法1
</code></pre>
<pre><code class="c++">void DoYourWork(EE *pe) &#123;
    if (typeid(MT) == typeid(*pe))
        ((MT *)pe)-&gt;Call();
    if (typeid(CA) == typeid(*pe))
        ((CA *)pe)-&gt;TakePhoto();
&#125;
//用法2
//不能直接使用 pe-&gt;Call();  编译期出错。
//也不能直接使用 ((MT*)pe)-&gt;Call(); 存在潜在的运行期错误
//可以使用我们定义的WhoAmI来代替typeid完成其功能
//if(pe-&gt;WhoAmI()…….)    ((MT*)pe)-&gt;Call();
//在准确地了解了对象的类型后,就可以正确地转换,从而进行正确的调用.这样可以安全地使用基类指针来操作子类对象了：
EE *pe;
if (SUNSHINE)
    pe = new MT;
else
    pe = new CA;
DoYourWork(pe);    // 在运行期识别对象的身份，并进行合适的操作。
</code></pre>
<h1 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h1><pre><code class="c++">EE *pe1 = new MT;
</code></pre>
<p>使用基类指针指向子类对象，实际上是一个类型转换。称为向上转换，<code>upcast</code>，向上转换是为了统一性。</p>
<pre><code class="c++">if (typeid(MT) == typeid(*pe))
    ((MT *)pe)-&gt;Call();
</code></pre>
<p>把基类指针再转换为子类指针，称为向下转换。<code>downcast</code>，向下转换是为了差异性。</p>
<p>在C++中有多种转换方法：隐式转换，显示转换，静态转换，动态转换。</p>
<h2 id="隐式转换"><a href="#隐式转换" class="headerlink" title="隐式转换"></a>隐式转换</h2><p>语法上直接使用<code>＝</code>操作符，比如<code>EE * pe1＝pmt；</code></p>
<p>只能用于向上转换，而且总是能成功。其他的非向上的隐式转换，编译出错。</p>
<h2 id="显示转换（强行转换）"><a href="#显示转换（强行转换）" class="headerlink" title="显示转换（强行转换）"></a>显示转换（强行转换）</h2><p>建议画图理清类和实例对象之间什么指向什么的关系，本笔记暂未摸清图床功能，遂省略。</p>
<h3 id="Upcast"><a href="#Upcast" class="headerlink" title="Upcast"></a>Upcast</h3><p>向上显式转换总可以成功（等价于隐示转换）。</p>
<pre><code class="c++">MTCA *pmtca = new MTCA;
MT *pmt = (MT *) pmtca; //等价于MT *pmt=pmtca;
</code></pre>
<h3 id="Downcast"><a href="#Downcast" class="headerlink" title="Downcast"></a>Downcast</h3><p>向下的隐式转换无法通过编译。</p>
<p>向下的显示转换总可以通过编译，但是无法得到转换的信息。</p>
<p>表面上总是可以成功，哪怕根本不相关的转换。有可能是假象，因此有可能发生运行时错误:：</p>
<pre><code class="c++">MT *pmt1 = new MT;
MT *pmt2 = new MTCA;
//两个基类指针分别指向基类和子类对象.
MTCA *pmatca0 = pmt1; //向下的隐式转换，编译出错
MTCA *pmtca1, *pmtca2;
pmtca1 = (MTCA *)pmt1;  //pmt1指向的是一个MT          假成功
pmtca2 = (MTCA *)pmt2; // pmt2指向的是一个MTCA.    真成功
pmtca1-&gt;TakePhoto ();   // 虽然能通过编译,但将引发运行时错误! 因为pmtca1根本就指向的是MT,没有TakePhoto方法!
pmtca2-&gt;TakePhoto ();  //这次,碰巧成功了.但用户无法控制.  只有通过“RTTI”才能分清, 比如WhoAmI.
</code></pre>
<p>向下的显示的转换，从<code>pmt-&gt;pmtca</code>，即<code>pmtca=(MTCA*)pmt;</code></p>
<p>用户无法从转换结果中判断<code>pmt</code>最初指向的是一个完整的子类对象（白色加蓝色），还是一个基类对象（纯蓝色）。</p>
<p>1.当<code>pmt</code>是一个完整的对象时（蓝色+白色），转换真正成功。</p>
<p>2.当<code>pmt</code>是纯蓝时，是一个假象。使用<code>pmtca</code>调用白色区域产生运行期错误。</p>
<p>无论哪种情况，都将得到一个指针<code>pmtca</code>。除非使用<code>RTTI</code>，莫辨真伪。</p>
<h3 id="Crosscast"><a href="#Crosscast" class="headerlink" title="Crosscast"></a>Crosscast</h3><p>交叉转换是为了执行目标类对象所能执行的功能（等价于一次向上转换和一次向下转换的综合）</p>
<pre><code class="c++">MT *pmt = new MTCA;
CA *pca = pmt;              //交叉隐式转换出错
CA *pca = (CA *)pmt;        //交叉显式转换可以编译甚至运行,但是......
pca-&gt;WhoAmI ();             // I am a MTCA
pca-&gt;TakePhoto ();          // MTCA is calling  !!!!
                            //不是MTCA is takephoto!!!!
//而且进一步, pca-&gt;pixel实际上仍然是MT所定义的rent的值! 
//(如果,比如在MT的构造函数内对rent赋值为50, 在CA的构造函数对pixel赋值为300万. 我们看到pca-&gt;pixel=50.)
//而实际上显示的cross cast的结果,见棕色部分.尤其注意TakePhoto 函数和Pixel变量,在它们的内存位置实际上保存的是Call的函数指针和rent变量.
</code></pre>
<p>使用显式的交叉转换并不安全。</p>
<p>虚表中的可见部分不能被改变。<code>Pca</code>所指向的对象的虚表仍然是原来的虚表（即<code>MT</code>类的）编译器根据名字<code>TakePhoto</code>在虚表中找到第三项，但是其中的指针指向的是<code>MT</code>类的<code>Call</code>，其实现是<code>MTCA</code>类的对它的实现<code>MTCA is takephoto</code>。</p>
<p>所以声明虚函数成员的时候，有时其次序也很重要！</p>
<p>如果在<code>MT</code>中再声明一个虚函数</p>
<pre><code class="c++">virtual void dd() &#123;	cout &lt;&lt; &quot;dfdfdfdfd&quot; &lt;&lt; endl;&#125;;
</code></pre>
<p>并且排在Call函数之前，那么：</p>
<p>以上<code>pca-&gt;TakePhoto ();</code>的结果将为：<code>dfdfdfdfd</code>。</p>
<p>这种特性，有时也有其独特的用途。</p>
<h2 id="动态转换"><a href="#动态转换" class="headerlink" title="动态转换"></a>动态转换</h2><p>运算符语法：</p>
<pre><code class="c++">dynamic_cast &lt; type - id &gt; ( expression )
//type-id是事先定义的类的指针或引用类型.
//Expression是一个指针或一个左值.
</code></pre>
<h3 id="Upcast-1"><a href="#Upcast-1" class="headerlink" title="Upcast"></a>Upcast</h3><pre><code class="c++">void f(MTCA *pmc) &#123;
    MT *pm = dynamic_cast&lt;MT *&gt;(pmc);
    // 转换到基类    pm指向pmc的MT型子对象
    EE *pe = dynamic_cast&lt;EE *&gt;(pm);
    //转换到基类    pe指向pm的EE型子对象
&#125;
</code></pre>
<p>实际上<code>upcast</code>不需要使用<code>dynamic_cast</code>，直接使用隐式转换即可。</p>
<h3 id="Downcast-1"><a href="#Downcast-1" class="headerlink" title="Downcast"></a>Downcast</h3><pre><code class="c++">void f() &#123;
    MT *pmt1 = new MTCA;   //基类指针指向一个派生类对象
    MT *pmt2 = new MT; //基类指针指向一个基类对象

    MTCA *pmtca1 = dynamic_cast&lt;MTCA *&gt;(pmt1);     // 成功！pmt1本来指的就是一个派生类对象
    MTCA *pmtca2 = dynamic_cast&lt;MTCA *&gt;(pmt2);
    // 失败！pmt2 指的是一个基类对象，无法转换为子类， pmtca2 == NULL
    ...
&#125;
</code></pre>
<p>用户可以根据返回值来决定下一步的走向。使用<code>dynamic_cast</code>可以安全地进行向下转换，避免使用显示的向下转换出现的问题（见前文显示的向下转换）。</p>
<h3 id="Crosscast-1"><a href="#Crosscast-1" class="headerlink" title="Crosscast"></a>Crosscast</h3><pre><code class="c++">MT *pmt = new MTCA;
CA *pca = (CA *)pmt;   //交叉显示转换可以成功,但是......
pca-&gt;WhoAmI ();         // I am a MTCA
pca-&gt;TakePhoto ();      // MTCA is calling  !!!!
//不是MTCA is takephoto!!!!
//这里pca的虚表指针所指向的虚表的可见部分是MT的虚表
pca = dynamic_cast&lt;CA *&gt;(pmt);
pca-&gt;WhoAmI ();         // I am a MTCA
pca-&gt;TakePhoto ();      // MTCA is takephoto!!!!  转换成功
// pca的虚表指针所指向的虚表的可见部分是CA的虚表!
//见前图p34
//实际上没图，在ppt里边:-(
</code></pre>
<h2 id="静态转换"><a href="#静态转换" class="headerlink" title="静态转换"></a>静态转换</h2><p>语法：</p>
<pre><code class="c++">static_cast &lt; type - id &gt; ( expression )
</code></pre>
<p>静态转换功能类似于显示的类型转换，不能提供安全性。</p>
<h3 id="Upcast-2"><a href="#Upcast-2" class="headerlink" title="Upcast"></a>Upcast</h3><p>总是成功，同显示转换。</p>
<h3 id="Downcast-2"><a href="#Downcast-2" class="headerlink" title="Downcast"></a>Downcast</h3><pre><code class="c++">MT *pmt1 = new MT;
MT *pmt2 = new MTCA pmtca; //向上隐式转换
pmtca1 = dynamic_cast&lt;MTCA *&gt;(pmt1); //pmtca1==NULL,应用可借此判断pmt1不是指向的MTCA对象, 不应继续使用pmtca1.
pmtca2 = dynamic_cast&lt;MTCA *&gt;(pmt2); //pmtca2!=NULL,pmtca2成功地指向一个MTCA对象,可以使用！
pmtca1 = static_cast&lt;MTCA *&gt;(pmt1);
pmtca1-&gt;TakePhoto (); //同显示转换,虽通过编译,但会引发运行时错误.
pmtca2 = static_cast&lt;MTCA *&gt;(pmt2);
//在这种情况下与dynamic_cast，显示转换等价.
pmtca2-&gt;TakePhoto ();
</code></pre>
<h3 id="Crosscast-2"><a href="#Crosscast-2" class="headerlink" title="Crosscast"></a>Crosscast</h3><pre><code class="c++">class a;
class b;
a *pa = new a;//欸我自己在编译的时候报错说使用不完整类型 应该代码补全了就没有这个问题了吧
b *pb = (b *) pa; //编译可以通过,此处也可以运行
//但是之后的调用会引起各种运行期问题.
pb = static_cast&lt;b *&gt;(pa); //编译出错,
//static_cast不支持交叉转换,避免了运行出错.
// 在这种意义static_cast具有价高的安全性：
//产生编译期的错误,
//而不是运行期不可预见的错误
</code></pre>
<p><code>static_cast</code>的实现方式是在对象与子对象之间进行偏移计算而得出。而<code>dynamic_cast</code>有时会改变虚表指针所指向虚表的可见部分。</p>
<h2 id="转换方式比较"><a href="#转换方式比较" class="headerlink" title="转换方式比较"></a>转换方式比较</h2><ul>
<li><p>运行原理：</p>
<p>隐式、显示、静态：在对象与子对象之间进行偏移量的计算，调整指针的指向。</p>
<p>动态：对对象进行全面的类型分析，有时要进行复杂的操作，包括对类的虚表。</p>
</li>
<li><p>运行速度：</p>
<p>隐式、显示、静态：快。</p>
<p>动态：相对慢。</p>
</li>
<li><p>安全性对比：</p>
<p>显示、静态、动态：安全性递增。</p>
<p>隐式转换总是安全的，但功能有限，只能进行向上转换。</p>
</li>
<li><p>使用策略：</p>
<p>尽可能地使用隐式、静态、显示转换，只在迫不得已时使用动态转换。</p>
<p>如使用动态转换，须设置编译器选项<code>enable RTTI</code>。</p>
<p>动态转换的问题：速度以及编译器相关性。</p>
</li>
</ul>
<h1 id="复合结构下的构造与析构函数"><a href="#复合结构下的构造与析构函数" class="headerlink" title="复合结构下的构造与析构函数"></a>复合结构下的构造与析构函数</h1><p>构造函数和析构函数都是成员函数。</p>
<p>构造函数可以重载（多种参数类型），析构函数不能重载（无参数）。</p>
<p>构造函数不能是虚函数（构造时必须指明类型），析构函数可以是（并且往往是）虚函数（用来释放子类的内存）。</p>
<p>程序中不能直接调用构造函数和析构函数，只能在创建对象时系统自动调用。</p>
<p>构造函数和析构函数的调用时间：全局变量：在进入<code>main()</code>函数之前会调用构造函数，在程序终止时会调用析构函数。自动变量的作用域是模块被激活时，自动变量调用构造函数，当退出此模块时，会调用析构函数。动态分配的对象：当使用<code>new</code>为对象分配内存时会调用构造函数；使用<code>delete</code>删除对象时会调用析构函数。</p>
<p>继承时构造和析构函数的调用：在派生类构造函数调用之前先调用基类的构造函数，析构函数的调用之后调用基类的析构函数。</p>
<p>嵌套时构造和析构函数的调用：调用对象的构造函数之前会调用嵌套对象的构造函数，调用对象的析构函数之后会调用嵌套对象的析构函数。</p>
<pre><code class="c++">//例子
class B &#123;
&#125;;

int main() &#123;
    B b;    // 警告：未引用的局部变量
    B *pb = new B(); // 编译器自动分配一个默认的构造函数。
&#125;
</code></pre>
<p>未定义构造函数：</p>
<pre><code class="c++">#include &lt;iostream&gt;

class B &#123;
    public:
        int ib;
&#125;;

int main() &#123;
    B b;
    B *pb = new B();
    std::cout &lt;&lt; b.ib &lt;&lt; std::endl; // 警告：使用未初始化的内存b
    //  错误：使用未初始化的局部变量b
    std::cout &lt;&lt; pb-&gt;ib &lt;&lt; std::endl;
&#125;//但是最后输出0和0欸
</code></pre>
<p>自行定义一个默认的构造，但未赋值：</p>
<pre><code class="c++">class B &#123;
    public:
        int ib;
        B() &#123;&#125;  // 警告： 未初始化ib
&#125;;

int main() &#123;
    B b;
    B *pb = new B();
    cout &lt;&lt; b.ib &lt;&lt; endl;  // 随机数，-858993460
    cout &lt;&lt; pb-&gt;ib &lt;&lt; endl; // 随机数，-842150451
&#125;
</code></pre>
<p>自行定义一个默认的构造：</p>
<pre><code class="c++">#include &lt;iostream&gt;
using namespace std;

class B &#123;
    public:
        int ib;
        B() &#123;
            ib = 1;
        &#125;
&#125;;

int main() &#123;
    B b;
    B *pb = new B();
    cout &lt;&lt; b.ib &lt;&lt; endl; // 1
    cout &lt;&lt; pb-&gt;ib &lt;&lt; endl; // 1
&#125;//输出1和1
</code></pre>
<p>构造函数的重载：</p>
<pre><code class="c++">class B &#123;
    public:
        int ib;
        B() &#123;
            ib = 1;
        &#125;
        B(int pi) &#123;
            ib = pi;
        &#125;
&#125;;

int main() &#123;
    B b;
    B *pb = new B(2);
    cout &lt;&lt; b.ib &lt;&lt; endl;   // 1
    cout &lt;&lt; pb-&gt;ib &lt;&lt; endl; // 2
&#125;
</code></pre>
<p>继承关系：</p>
<pre><code class="c++">class B &#123;
    public:
        int ib;
        B() &#123;
            ib = 1;
        &#125;
        B(int pi) &#123;
            ib = pi;
        &#125;
&#125;;

class D: public B &#123;
    public:
        int id;
&#125;;

int main() &#123;
    D d;
    D *pd = new D();;
    cout &lt;&lt; d.ib &lt;&lt; endl;      // 1
    cout &lt;&lt; pd-&gt;ib &lt;&lt; endl;  // 1
&#125;
//编译器自动为D分配一个默认的构造函数
</code></pre>
<p>为子类自定义默认构造函数：</p>
<pre><code class="c++">class B &#123;
    public:
        int ib;
        B() &#123;
            cout &lt;&lt; &quot;in B&quot; &lt;&lt; endl; // 输出执行痕迹
            ib = 1;
        &#125;
        B(int pi) &#123;
            ib = pi;
        &#125;
&#125;;

class D: public B &#123;
    public:
        int id;
        D() &#123;
            cout &lt;&lt; &quot;in D&quot; &lt;&lt; endl;  // 输出执行痕迹
            id = 11;
        &#125;
&#125;;

int main() &#123;
    D *pd = new D();    // in B
    // in D
    cout &lt;&lt; pd-&gt;ib &lt;&lt; &quot; &quot; &lt;&lt; pd-&gt;id &lt;&lt; endl; //  1   11
    delete pd;
&#125;
//逆流而上，递归调用。
</code></pre>
<p>构造函数重载：</p>
<pre><code class="c++">class B &#123;
    public:
        int ib;
        B() &#123;
            cout &lt;&lt; &quot;in B 1&quot; &lt;&lt; endl;
            ib = 1;
        &#125;
        B(int pi) &#123; // 基类的第二个构造
            cout &lt;&lt; &quot;in B 2 &quot; &lt;&lt; endl;
            ib = pi;
        &#125;
&#125;;

class D: public B &#123;
    public:
        int id;
        D() &#123;
            cout &lt;&lt; &quot;in D 1&quot; &lt;&lt; endl;
            id = 11;
        &#125;
        D(int pi) &#123; // 子类的第二个构造函数
            cout &lt;&lt; &quot;in D 2&quot; &lt;&lt; endl;
            id = pi;
        &#125;
&#125;;

int main() &#123;
    D *pd = new D();    // in B 1
    // in D 1
    cout &lt;&lt; pd-&gt;ib &lt;&lt; &quot; &quot; &lt;&lt; pd-&gt;id &lt;&lt; endl; //  1  11
    delete pd;
&#125;
</code></pre>
<p>根据参数，找到不同的重载：</p>
<pre><code class="c++">int main() &#123;
    D *pd = new D();      // 调用第一个构造
    cout &lt;&lt; pd-&gt;ib &lt;&lt; &quot; &quot; &lt;&lt; pd-&gt;id &lt;&lt; endl;
    delete pd;
    D *pd2 = new D(12); // 调用第二个构造
    cout &lt;&lt; pd2-&gt;ib &lt;&lt; &quot; &quot; &lt;&lt; pd2-&gt;id &lt;&lt; endl;
    delete pd2;
    return 0;
&#125;
//输出：
//in B 1
//in D 1
//1 11
//in B 1
//in D 2
//1 12
//但是都是调用的B的第一个默认构造。
//子类构造如未指定，均调用基类的默认构造

class D: public B &#123;
    public:
        int id;
        D() &#123; // 调用B1
            cout &lt;&lt; &quot;in D 1&quot; &lt;&lt; endl;
            id = 11;
        &#125;
        D(int pi) &#123; // 调用B1
            cout &lt;&lt; &quot;in D 2&quot; &lt;&lt; endl;
            id = pi;
        &#125;
&#125;;

//也可以显示地指明调用基类的那个重载构造
D(): B(5) &#123; // 在D1中显示调用B2：
    cout &lt;&lt; &quot;in D 1&quot; &lt;&lt; endl;
    id = 11;
&#125;

D(int pi): B() &#123; // 在D2 中显示调用B1
    cout &lt;&lt; &quot;in D 2&quot; &lt;&lt; endl;
    id = pi;
&#125;
//此时输出：
//in B 2
//in D 1
//5 11
//in B 1
//in D 2
//1 12 

//或者：（一切根据程序员的意图行事）

class D: public B &#123;
    public:
        int id;
        D() &#123; // 调用默认的B1
            cout &lt;&lt; &quot;in D 1&quot; &lt;&lt; endl;
            id = 11;
        &#125;
        D(int pi): B(pi + 1) &#123; // 调用B2
            cout &lt;&lt; &quot;in D 2&quot; &lt;&lt; endl;
            id = pi;
        &#125;
&#125;;
//输出：
//in B 1
//in D 1
//1 11
//in B 2
//in D 2
//13 12
</code></pre>
<p>注意：构造函数不能是虚拟的，且必须是<code>inline</code>。（无须指明）</p>
<p>拷贝构造函数：</p>
<pre><code class="c++">//给子类增加一个拷贝构造：（同时，可选地指定基类的构造）
D(const D &amp;d): B(d.ib + 1) &#123;
    this-&gt;id = d.id;
&#125;

//使用方法：
D *pd = new D();
D *pd2 = new D(*pd);
D pd3(*pd);
</code></pre>
<p>重载<code>=</code>运算符：</p>
<pre><code class="c++">D &amp;operator=(const D &amp;d) &#123;
    D *pd = new D(d);
    return *pd;
&#125;

//使用方法：

D *pd = new D();
D *pd2 = new D(*pd);
D pd3(*pd);
D pd4 = pd3;
</code></pre>
<p>析构函数举例：</p>
<pre><code class="c++">class B &#123;
    public:
        int ib;
        B() &#123;
            cout &lt;&lt; &quot;in B 1&quot; &lt;&lt; endl;
            ib = 1;
        &#125;
        B(int pi) &#123;
            cout &lt;&lt; &quot;in B 2 &quot; &lt;&lt; endl;
            ib = pi;
        &#125;
        ~B() &#123; // 基类析构
            cout &lt;&lt; &quot;in ~ B&quot; &lt;&lt; endl;
        &#125;
&#125;;

class D: public B &#123;
    public:
        int id;
        D() &#123;
            cout &lt;&lt; &quot;in D 1&quot; &lt;&lt; endl;
            id = 11;
        &#125;
        D(int pi): B(pi - 1) &#123;
            cout &lt;&lt; &quot;in D 2&quot; &lt;&lt; endl;
            id = pi;
        &#125;
        ~D() &#123; // 子类析构
            cout &lt;&lt; &quot;in ~ D &quot; &lt;&lt; endl;
        &#125;
&#125;;

int main() &#123;
    D *pd = new D(5);
    cout &lt;&lt; pd-&gt;ib &lt;&lt; &quot; &quot; &lt;&lt; pd-&gt;id &lt;&lt; endl;
    delete pd;
&#125;
//输出：
//in B 2
//in D 2
//4 5
//in ~ D
//in ~ B
//注意执行的顺序！

//不能重载。无参数。往往为虚.
</code></pre>
<p>内存的分配与释放：</p>
<pre><code class="c++">class B &#123;
    public:
        int *pib;
        B() &#123;
            cout &lt;&lt; &quot;in B&quot; &lt;&lt; endl;
            pib = new int[1000 * 1000];
        &#125;
        ~B() &#123;
            cout &lt;&lt; &quot;in ~ B&quot; &lt;&lt; endl;
            delete[]pib;  // 释放内存
        &#125;
&#125;;

class D : public B &#123;
    public:
        int *pid;
        D() &#123;
            cout &lt;&lt; &quot;in D&quot; &lt;&lt; endl;
            pid = new int[1000 * 1000];
        &#125;
        ~D() &#123;
            cout &lt;&lt; &quot;in ~ D &quot; &lt;&lt; endl;
            delete[]pid; // 释放内存
        &#125;
&#125;;

int main() &#123;
    D *pd = new D();
    delete pd;
&#125;

//输出：
//in B
//in D
//in ~ D
//in ~ B

//但是如果改为：

int main() &#123;
    B *pb = new D();
    delete pb;
&#125;

//输出：
//in B
//in D
//in ~ B

//D的析构未被调用，发生了内存泄漏
</code></pre>
<h1 id="虚析构"><a href="#虚析构" class="headerlink" title="虚析构"></a>虚析构</h1><pre><code class="c++">class B &#123;
    public:
        int *pib;
        B() &#123;
            cout &lt;&lt; &quot;in B&quot; &lt;&lt; endl;
            pib = new int[1000 * 1000];
        &#125;
        virtual  ~B() &#123;
            cout &lt;&lt; &quot;in ~ B&quot; &lt;&lt; endl;
            delete[]pib;
        &#125;
&#125;;

class D : public B &#123;
    public:
        int *pid;
        D() &#123;
            cout &lt;&lt; &quot;in D&quot; &lt;&lt; endl;
            pid = new int[1000 * 1000];
        &#125;
        ~D() &#123;
            cout &lt;&lt; &quot;in ~ D &quot; &lt;&lt; endl;
            delete[]pid;
        &#125;
&#125;;

int main() &#123;
    B *pb = new D();
    delete pb;
&#125;
//输出：
//in B
//in D
//in ~ D
//in ~ B
</code></pre>

        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2022/05/30/5_Operator_Overloading/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          #5 运算符重载
        
      </div>
    </a>
  
  
    <a href="/2022/05/19/3_class_and_object/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">#3 类与对象</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=#4 继承与多态 - Function's Blog&url=http%3A%2F%2Fblog.functioneurus.com%2F2022%2F05%2F20%2F4_Inheritance_and_Polymorphism%2F">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=#4 继承与多态 - Function's Blog&u=http%3A%2F%2Fblog.functioneurus.com%2F2022%2F05%2F20%2F4_Inheritance_and_Polymorphism%2F">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=#4 继承与多态 - Function's Blog&url=http://blog.functioneurus.com/2022/05/20/4_Inheritance_and_Polymorphism/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/408/" rel="tag">408</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memo/" rel="tag">Memo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%B1%E7%BF%BB%E4%B9%A6/" rel="tag">乱翻书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E4%BA%BA/" rel="tag">同人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%9F%E8%AF%9D/" rel="tag">废话</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/06/02/broken_thoughts_in_23_JUNE/">碎碎念存档_JUNE</a>
          </li>
        
          <li>
            <a href="/2023/05/04/broken_thoughts_in_23_MAY/">碎碎念存档_MAY</a>
          </li>
        
          <li>
            <a href="/2023/04/01/broken_thoughts_in_APR/">碎碎念存档_APR</a>
          </li>
        
          <li>
            <a href="/2023/03/26/16_Database_notes/">#16 数据库看书笔记</a>
          </li>
        
          <li>
            <a href="/2023/03/01/broken_thoughts_in_MAR/">碎碎念存档_MAR</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Function&#39;s Blog &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1651727875408.js"></script>


<script src="/dist/custom.js?1651727875408.js"></script>













</body>

</html>