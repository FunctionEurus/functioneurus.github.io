<!DOCTYPE html>
<html>

<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

    
    <title>#13 王道408计组听课笔记 | Function&#39;s Blog</title>

    <meta name="description" content="&lt;p&gt;&lt;del&gt;我放弃了  本来打算记录阅读Intoduction to Java Programming and Data Structures的  但我觉得我不行&lt;/del&gt;&lt;/p&gt;">
    <meta name="keywords" content="">

    

    <meta property="og:locale" content="zh-CN" />
    <meta property="og:type" content="article" />
    <meta property="og:title" content= "#13 王道408计组听课笔记 | Function&#39;s Blog"  />
    <meta property="og:description" content= "&lt;p&gt;&lt;del&gt;我放弃了  本来打算记录阅读Intoduction to Java Programming and Data Structures的  但我觉得我不行&lt;/del&gt;&lt;/p&gt;" />
    <meta property="og:url" content="http://blog.functioneurus.com/2022/06/27/13_Note_of_Principles_of_Computer_Composition/index.html" />
    <meta property="og:site_name" content="" />
    <meta property="article:author" content="Function" />
    <meta property="article:publisher" content="" />
    <meta property="og:description" content="&lt;p&gt;&lt;del&gt;我放弃了  本来打算记录阅读Intoduction to Java Programming and Data Structures的  但我觉得我不行&lt;/del&gt;&lt;/p&gt;" />
    <meta name="twitter:title" content="#13 王道408计组听课笔记 | Function&#39;s Blog"/>
    <meta name="twitter:description" content="&lt;p&gt;&lt;del&gt;我放弃了  本来打算记录阅读Intoduction to Java Programming and Data Structures的  但我觉得我不行&lt;/del&gt;&lt;/p&gt;"/>
    <script type="application/ld+json">
        {
            "description": "&lt;p&gt;&lt;del&gt;我放弃了  本来打算记录阅读Intoduction to Java Programming and Data Structures的  但我觉得我不行&lt;/del&gt;&lt;/p&gt;",
            "author": { "@type": "Person", "name": "Function" },
            "@type": "BlogPosting",
            "url": "http://blog.functioneurus.com/2022/06/27/13_Note_of_Principles_of_Computer_Composition/index.html",
            "publisher": {
            "@type": "Organization",
            "logo": {
                "@type": "ImageObject",
                "url": "http://blog.functioneurus.comundefined"
            },
            "name": "Function"
            },
            "headline": "#13 王道408计组听课笔记 | Function&#39;s Blog",
            "datePublished": "2022-06-26T23:08:30.000Z",
            "mainEntityOfPage": {
                "@type": "WebPage",
                "@id": "http://blog.functioneurus.com/2022/06/27/13_Note_of_Principles_of_Computer_Composition/index.html"
            },
            "@context": "http://schema.org"
        }
    </script>




    

    

    

    

    

    

    

    
<link rel="stylesheet" href="/dist/build.css?v=1651727875408.css">


    
<link rel="stylesheet" href="/dist/custom.css?v=1651727875408.css">


    <script>
        window.isPost = true
        window.aomori = {
            
            
            
        }
        window.aomori_logo_typed_animated = false
        window.aomori_search_algolia = false

    </script>

<meta name="generator" content="Hexo 6.1.0"></head>

<body>

    <div class="container">
    <header class="header">
        <div class="header-type">
            
            <div class="header-type-inner">
                
                    <a class="header-type-title" href="/">Function&#39;s Blog</a>
                
    
                
            </div>
        </div>
        <div class="header-menu">
            <div class="header-menu-inner">
                
                <a href="/">Home</a>
                
                <a href="/archives">Archives</a>
                
            </div>
            <div class="header-menu-social">
                
            </div>
        </div>

        <div class="header-menu-mobile">
            <div class="header-menu-mobile-inner" id="mobile-menu-open">
                <i class="icon icon-menu"></i>
            </div>
        </div>
    </header>

    <div class="header-menu-mobile-menu">
        <div class="header-menu-mobile-menu-bg"></div>
        <div class="header-menu-mobile-menu-wrap">
            <div class="header-menu-mobile-menu-inner">
                <div class="header-menu-mobile-menu-close" id="mobile-menu-close">
                    <i class="icon icon-cross"></i>
                </div>
                <div class="header-menu-mobile-menu-list">
                    
                    <a href="/">Home</a>
                    
                    <a href="/archives">Archives</a>
                    
                </div>
            </div>
        </div>
    </div>

</div>

    <div class="container">
        <div class="main">
            <section class="inner">
                <section class="inner-main">
                    <div class="post">
    <article id="post-clj8jslkm0005vwco04xx3bvr" class="article article-type-post" itemscope
    itemprop="blogPost">

    <div class="article-inner">

        
          
        
        
        

        
        <header class="article-header">
            
  
    <h1 class="article-title" itemprop="name">
      #13 王道408计组听课笔记
    </h1>
  

        </header>
        

        <div class="article-more-info article-more-info-post hairline">

            <div class="article-date">
  <time datetime="2022-06-26T23:08:30.000Z" itemprop="datePublished">2022-06-27</time>
</div>

            

            
            <div class="article-tag">
                <ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/408/" rel="tag">408</a></li></ul>
            </div>
            

            

        </div>

        <div class="article-entry post-inner-html hairline" itemprop="articleBody">
            <p><del>我放弃了  本来打算记录阅读Intoduction to Java Programming and Data Structures的  但我觉得我不行</del></p>
<span id="more"></span>

<h1 id="王道408-计算机组成原理听课笔记"><a href="#王道408-计算机组成原理听课笔记" class="headerlink" title="王道408 计算机组成原理听课笔记"></a>王道408 计算机组成原理听课笔记</h1><h1 id="第一章-计算机系统概述"><a href="#第一章-计算机系统概述" class="headerlink" title="第一章 计算机系统概述"></a>第一章 计算机系统概述</h1><h2 id="1-0-简介"><a href="#1-0-简介" class="headerlink" title="1.0 简介"></a>1.0 简介</h2><p>计算机硬件就在我们身边，常见的有CPU内外存显卡等等。上边都有针脚，可以连接到主板上，高低电平分别代表10通过针脚与计算机交换信号，每个二进制位称为比特bit。</p>
<h2 id="1-1-计算机的发展"><a href="#1-1-计算机的发展" class="headerlink" title="1.1 计算机的发展"></a>1.1 计算机的发展</h2><h4 id="什么是计算机系统"><a href="#什么是计算机系统" class="headerlink" title="什么是计算机系统"></a>什么是计算机系统</h4><p>计算机系统 &#x3D; 硬件 + 软件，性能好坏取决于二者总和。</p>
<p>软件可分为系统软件（如OS、数据库管理系统、网络软件、语言处理程序等）和应用软件。</p>
<h4 id="硬件的发展"><a href="#硬件的发展" class="headerlink" title="硬件的发展"></a>硬件的发展</h4><p>1946年第一台电子数字计算机埃尼阿克诞生，以电子管作为它的逻辑元件，使用机器语言编程。</p>
<p>第二代计算机使用晶体管（1947年by贝尔实验室），出现了高级编程语言，操作系统出现雏形。</p>
<p>第三代计算机开始使用集成电路（1959年by仙童半导体，之后诞生了Intel和AMD），但规模为中小规模，第四代则为大规模、超大规模集成电路，开始出现CPU、操作系统。</p>
<p>机器字长：CPU一次整数运算能处理的二进制数据位数。</p>
<p>摩尔定律：18个月翻番。</p>
<h4 id="软件的发展"><a href="#软件的发展" class="headerlink" title="软件的发展"></a>软件的发展</h4><p>机器语言 -&gt; 汇编语言 -&gt; 高级编程语言。</p>
<h4 id="发展趋势"><a href="#发展趋势" class="headerlink" title="发展趋势"></a>发展趋势</h4><p>更微型化、多用途；更巨型化、超高速。</p>
<h3 id="1-2-1-计算机硬件的基本组成"><a href="#1-2-1-计算机硬件的基本组成" class="headerlink" title="1.2.1 计算机硬件的基本组成"></a>1.2.1 计算机硬件的基本组成</h3><p>为解决埃尼阿克需要手动接线来控制计算的问题，冯诺依曼提出了储存程序的概念。</p>
<p>储存程序指将指令以二进制代码的形式事先输入计算机的主储存器（内存），然后按其在储存器中的首地址执行程序的第一条指令，之后按顺序执行其他指令直至执行结束。</p>
<p>在计算机系统中，软件和硬件在逻辑上是等效的，但是成本和效率有区别。</p>
<h4 id="冯诺依曼结构的特点"><a href="#冯诺依曼结构的特点" class="headerlink" title="冯诺依曼结构的特点"></a>冯诺依曼结构的特点</h4><p>由五大IO部件（输入设备（A&#x2F;D）、运算器、存储器、控制器、输出设备（D&#x2F;A））组成。</p>
<p>指令和数据以同等地位存于存储器，可按地址寻访。</p>
<p>指令和数据用二进制表示。</p>
<p>指令由操作码和地址码组成。</p>
<p>存储程序。</p>
<p>以运算器为中心——IO设备与存储器之间的数据传输均通过运算器完成，但是数据计算的效率降低。</p>
<h4 id="现代计算机的结构"><a href="#现代计算机的结构" class="headerlink" title="现代计算机的结构"></a>现代计算机的结构</h4><p>以存储器为中心，CPU整合了运算器和控制器，解决了冯诺依曼结构的一个大问题。</p>
<p>存储器包括主存和辅存，其中主存属于主机，辅存属于IO设备。</p>
<h3 id="1-2-2-各个硬件部件工作原理"><a href="#1-2-2-各个硬件部件工作原理" class="headerlink" title="1.2.2 各个硬件部件工作原理"></a>1.2.2 各个硬件部件工作原理</h3><h4 id="主存储器的基本组成"><a href="#主存储器的基本组成" class="headerlink" title="主存储器的基本组成"></a>主存储器的基本组成</h4><p>储存体~货架：按地址存放数据，每个存储单位对应一个地址（从0开始）并存放一串二进制代码，即存储字，存储字长则为存储子的二进制代码位数。存储元即存储二进制的电子元件，每个存储元可存1bit。</p>
<p>MAR（Memory Address Register）地址寄存器~店员：位数反映存储单元的个数</p>
<p>MDR（Memory Data Register）数据寄存器~柜台：其位数等于存储字长</p>
<p>*区分大小b，一个字节一个比特。</p>
<h4 id="运算器的基本组成"><a href="#运算器的基本组成" class="headerlink" title="运算器的基本组成"></a>运算器的基本组成</h4><p>运算器：用于实现是算术运算（加减乘除）、逻辑运算（与或非）。</p>
<p>ACC（Accumulator）累加器：用于存放操作数或运算结果。</p>
<p>MQ（Multiple-Quotient Register）乘商寄存器：用于在乘除运算时存放操作数或运算结果。</p>
<p>X通用操作数寄存器：用于存放操作数。</p>
<p>ALU（Arithmetic and Logic Unit）算术逻辑单元：运算器的核心部分，通过内部复杂的电路实现算术运算、逻辑运算。</p>
<h4 id="控制器的基本组成"><a href="#控制器的基本组成" class="headerlink" title="控制器的基本组成"></a>控制器的基本组成</h4><p>CU（Control Unit）控制单元：控制器的核心元件，用于分析指令，给出控制信号。</p>
<p>IR（Instruction Register）指令寄存器：用于存放当前执行的指令。</p>
<p>PC（Program Counter）程序计数器：用于存放下一条指令地址，有自动加一功能。</p>
<p>完成一条指令的过程：PC取出指令 -&gt; IR分析指令 -&gt; CU执行指令</p>
<h4 id="计算机的工作过程"><a href="#计算机的工作过程" class="headerlink" title="计算机的工作过程"></a>计算机的工作过程</h4><p>初始：指令、数据存入主存，PC指向第一条指令。</p>
<p>从主存中取出指令放入IR，PC自动加一，CU分析指令后指挥其他部件执行指令（划分出很多微指令）。</p>
<p>王道讲的超级详细（18min-32min）</p>
<p>*现在的计算机通常把MAR、MDR也集成到CPU里边了</p>
<h3 id="1-2-3-计算机系统的层次结构"><a href="#1-2-3-计算机系统的层次结构" class="headerlink" title="1.2.3 计算机系统的层次结构"></a>1.2.3 计算机系统的层次结构</h3><h4 id="计算机系统的层次结构"><a href="#计算机系统的层次结构" class="headerlink" title="计算机系统的层次结构"></a>计算机系统的层次结构</h4><p>M4：虚拟高级语言机器（执行高级语言，用编译程序翻译成汇编语言程序）</p>
<p>M3：虚拟汇编语言机器（执行汇编语言，用汇编程序翻译成机器语言程序）</p>
<p>M2：虚拟操作系统机器（向上提供广义指令，系统调用）</p>
<p>M1：传统机器（执行二进制机器语言指令）</p>
<p>M0：微程序机器（由硬件直接执行微指令）</p>
<h4 id="三种级别的语言"><a href="#三种级别的语言" class="headerlink" title="三种级别的语言"></a>三种级别的语言</h4><p>高级语言：如C&#x2F;C++等 –编译程序（编译器）–&gt; 汇编语言：助记符 –汇编程序（汇编器）–&gt; 机器语言：二进制代码。</p>
<p>若是JavaScript、Python等解释型语言则经过解释程序（解释器）形成机器语言。</p>
<p>编译程序和解释程序的区别在于只翻译一次还是每次执行语句时都要翻译。</p>
<h2 id="1-3-计算机的性能指标"><a href="#1-3-计算机的性能指标" class="headerlink" title="1.3 计算机的性能指标"></a>1.3 计算机的性能指标</h2><h4 id="存储器的性能指标"><a href="#存储器的性能指标" class="headerlink" title="存储器的性能指标"></a>存储器的性能指标</h4><p>MAR位数反映了存储单元的个数（共2^a个），MDR位数即存储字长，表示每个存储单元的大小。</p>
<p>总容量 &#x3D; (2 ^ a * d) bit &#x3D; (2 ^ a * d &#x2F; 8) Byte</p>
<h4 id="CPU的性能指标"><a href="#CPU的性能指标" class="headerlink" title="CPU的性能指标"></a>CPU的性能指标</h4><p>CPU主频：CPU内数字脉冲信号震荡的频率，与时钟周期互为倒数。</p>
<p>CPI（Clock cycle PerIstruction）：执行一条指令所需的时钟周期数，指令不同CPI就不同，甚至相同的指令CPI也可能不同。</p>
<p>CPU执行一条指令所需的时间 &#x3D; CPI * CPU时钟周期 &#x3D; CPI &#x2F; 主频。（IPS的倒数）</p>
<p>执行整个程序的耗时就在一条指令时间的基础上乘指令条数即可。</p>
<p>IPS（Instructions Per Second）：每秒执行指令的条数，&#x3D; 主频 &#x2F; 平均CPI。</p>
<p>FLOPS（Floating-point Operations Per Second）：每秒执行多少次浮点运算。</p>
<p>有时会在IPS和FLOPS前加上数量单位K、M、G、T等。</p>
<h4 id="系统整体的性能指标"><a href="#系统整体的性能指标" class="headerlink" title="系统整体的性能指标"></a>系统整体的性能指标</h4><p>数据通路带宽：数据总线一次能并行传送信息的位数（各硬件部件通过数据总线传输数据）。</p>
<p>吞吐量：系统在单位时间内可以处理的请求的数量，主要取决于主存的存取周期。</p>
<p>响应时间：指从用户向计算机发送一个请求到系统对该请求做出响应并获得她所需要的结果的等待时间。通常包括CPU时间（运行一个程序所花费的时间）与等待时间（用于磁盘访问、存储器访问、I&#x2F;O操作、操作系统开销等时间）。</p>
<h4 id="常用数量单位"><a href="#常用数量单位" class="headerlink" title="常用数量单位"></a>常用数量单位</h4><p>在描述存储容量、文件大小时：K &#x3D; 2^10，M &#x3D; 2^20，G &#x3D; 2^30，T &#x3D; 2^40</p>
<p>在描述频率、速率时：K &#x3D; 10^3，M &#x3D; 10^6，G &#x3D; 10^9，T &#x3D; 10^12</p>
<h1 id="第二章-数据的表示和运算"><a href="#第二章-数据的表示和运算" class="headerlink" title="第二章 数据的表示和运算"></a>第二章 数据的表示和运算</h1><h3 id="2-1-1-进位计数制"><a href="#2-1-1-进位计数制" class="headerlink" title="2.1.1 进位计数制"></a>2.1.1 进位计数制</h3><h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>方法：乘权求和，除r取余逆序输出，乘r取整正序输出，三&#x2F;四位一组，整数高位补位，小数低位补位。</p>
<h4 id="真值和机器数"><a href="#真值和机器数" class="headerlink" title="真值和机器数"></a>真值和机器数</h4><p>真值：人类习惯的实际带正负号的数值</p>
<p>机器数：将正负号数字化后存到机器里的数</p>
<h3 id="2-1-2-BCD码（Binary-Coded-Decimal）"><a href="#2-1-2-BCD码（Binary-Coded-Decimal）" class="headerlink" title="2.1.2 BCD码（Binary-Coded Decimal）"></a>2.1.2 BCD码（Binary-Coded Decimal）</h3><p>BCD码：用四个二进制位表示一个十进制数。</p>
<p>8421码：权值分别映射为8421。</p>
<p>8421码的加法：若结果在1010~1111的未定义范围内，则对结果继续加0110（6）实现进位效果。</p>
<p>余3码：由8421码加上0011（3）得到。</p>
<p>2421码：权值分别映射为2421，表示0<del>4时最高位为0，表示5</del>9时最高位为1。</p>
<h3 id="2-1-3-字符与字符串"><a href="#2-1-3-字符与字符串" class="headerlink" title="2.1.3 字符与字符串"></a>2.1.3 字符与字符串</h3><h4 id="英文字符在计算机内的表示"><a href="#英文字符在计算机内的表示" class="headerlink" title="英文字符在计算机内的表示"></a>英文字符在计算机内的表示</h4><p>ASCII码：128个常用字符用八个二进制位表示，32-126为可印刷字符，其余为控制、通信字符。48-0，65-A，97-a。</p>
<h4 id="中文字符在计算机内的表示"><a href="#中文字符在计算机内的表示" class="headerlink" title="中文字符在计算机内的表示"></a>中文字符在计算机内的表示</h4><p>GB2312码：分为区位码（94个区，每区94个位置 -&gt; 二维数组），在区位码的基础上+20H得到国标码，再+80H得到机内码。（避免通信时与ASCII码冲突）</p>
<p>输入编码，如拼音、五笔输入法。</p>
<p>输出编码：汉字字形码。</p>
<h4 id="字符串的存储"><a href="#字符串的存储" class="headerlink" title="字符串的存储"></a>字符串的存储</h4><p>字符串在计算机内储存是从低地址到高地址逐个字符存储，通常以’\0’结束。</p>
<p>大端模式：将数据的最高有效字节存放在低地址单元中。</p>
<p>小端模式：将数据的最高有效字节存放在高地址单元中。</p>
<h3 id="2-1-4-奇偶校验码"><a href="#2-1-4-奇偶校验码" class="headerlink" title="2.1.4 奇偶校验码"></a>2.1.4 奇偶校验码</h3><h4 id="校验原理"><a href="#校验原理" class="headerlink" title="校验原理"></a>校验原理</h4><p>由若干位代码组成的一个字叫码字。</p>
<p>将两个码字逐位进行对比，具有不同的位的个数称为两个码字间的距离。</p>
<p>一种编码方案可能有若干个合法码字，各个合法码字间的最小距离称为码距（d）。</p>
<p>当d&#x3D;1时，无检错能力；当d&#x3D;2时，有检错能力；当d&gt;&#x3D;3时，若设计合理，可以具有检错、纠错功能。</p>
<h4 id="奇偶校验"><a href="#奇偶校验" class="headerlink" title="奇偶校验"></a>奇偶校验</h4><p>奇偶校验码：在有效信息位的最前&#x2F;最后添加一位奇偶校验位，若为奇校验码，则校验位需要使得整个校验码中1的个数为奇数，同理偶校验码需要使得整个校验码中1的个数为偶数。</p>
<p>奇偶校验只能检查出奇数个比特位跳变产生的错误，且无法确定是哪一位出错，也无法纠错，只能要求重传。因为一个校验位只能携带两种状态信息（对&#x2F;错）。</p>
<p>偶校验的硬件实现：各信息进行异或（模2加）运算即可得到偶校验位。</p>
<h3 id="2-1-5-海明校验码（需要再看一遍）"><a href="#2-1-5-海明校验码（需要再看一遍）" class="headerlink" title="2.1.5 海明校验码（需要再看一遍）"></a>2.1.5 海明校验码（需要再看一遍）</h3><h4 id="设计思路"><a href="#设计思路" class="headerlink" title="设计思路"></a>设计思路</h4><p>将信息位分组进行偶校验 -&gt; 产生多个校验位 -&gt; 多个校验位能携带多种状态信息，标注出错位置。</p>
<h4 id="求解步骤"><a href="#求解步骤" class="headerlink" title="求解步骤"></a>求解步骤</h4><p>确定校验位数：k个校验位，n个信息位，需满足2^k&gt;&#x3D;n+k+1的要求。</p>
<p>确定校验位分布：Pi在2^i位，空出来的其他位置依次填入信息位。</p>
<p>求校验位：将信息位的位置序号用k位二进制数表示出来，校验位Pi与位置序号第i位为1的信息位归为同一组进行偶校验。</p>
<p>纠错：对P1，P2，P3…所属各分组进行异或（即分组偶校验）求出S1，S2，S3…，若全为0则说明没有错误，反之其值反映了出错位置。</p>
<h4 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h4><p>海明码有一位纠错能力，二位检错能力。</p>
<p>为区分一位错和二位错，还需添加“全校验位”对整体进行偶校验。</p>
<h3 id="2-1-6-循环冗余校验码（Cyclic-Redundancy-Check）"><a href="#2-1-6-循环冗余校验码（Cyclic-Redundancy-Check）" class="headerlink" title="2.1.6 循环冗余校验码（Cyclic Redundancy Check）"></a>2.1.6 循环冗余校验码（Cyclic Redundancy Check）</h3><h4 id="基本思想"><a href="#基本思想" class="headerlink" title="基本思想"></a>基本思想</h4><p>数据的发送方和接收方约定一个“除数”（题目中一般以生成多项式的方式给出），将K个信息位和R个校验位连接后作为“被除数”，要求添加校验位后除法所得的余数为0。接收方收到数据后，进行除法运算，检查余数是否为0，若非0则说明出错，需要重传或者纠错。</p>
<p>K为信息码的长度，R为生成多项式的最高次幂，总位数N&#x3D;K+R。</p>
<p>校验位由左移R位后的信息码模二除生成多项式的余数确定。（注意模二除法的运算方式）</p>
<h4 id="检错、纠错能力"><a href="#检错、纠错能力" class="headerlink" title="检错、纠错能力"></a>检错、纠错能力</h4><p>循环冗余校验码也具有纠错能力，但有时候因为设计不当无法实现。（数据长度超过了校验位所能表示的情况数）若2^R&gt;&#x3D;K+R+1，则CRC码可纠正单比特错。（实际应用中一般只用来检错）</p>
<p>理论上可以检测出所有奇数个错误，所有双比特错误，所有小于等于校验位长度的连续错误。</p>
<h3 id="2-2-1-定点数的表示"><a href="#2-2-1-定点数的表示" class="headerlink" title="2.2.1 定点数的表示"></a>2.2.1 定点数的表示</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><p>定点数：小数点的位置固定——常规计数</p>
<p>浮点数：小数点的位置不固定——科学计数法</p>
<p>定点整数的隐含小数位在末尾，定点小数的隐含小数位在符号位后。</p>
<h4 id="无符号数-Unsigned"><a href="#无符号数-Unsigned" class="headerlink" title="无符号数 Unsigned"></a>无符号数 Unsigned</h4><p>概念：整个机器字长的全部二进制位均为数值位，不存在数的符号位，相当于数的绝对值。</p>
<p>n位无符号数的表示范围为：0~2^n-1。</p>
<p>通常只有无符号整数，没有无符号小数。</p>
<h4 id="有符号数-Signed"><a href="#有符号数-Signed" class="headerlink" title="有符号数 Signed"></a>有符号数 Signed</h4><p>有符号数的定点表示：原码&#x2F;反码&#x2F;补码&#x2F;移码</p>
<h5 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h5><p>概念：用尾数表示真值的绝对值，符号位的0&#x2F;1对应正&#x2F;负。</p>
<p>真值0有+0和-0两种形式，故n+1位机器字长表示的原码整数范围为[-(2^n-1),2^n-1]，原码小数范围为[-(1-2^(-n)),1-2^(-n)]。</p>
<h5 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h5><p>若符号位为0，则反码与原码相同；若符号位为1，则数值位全部取反。</p>
<p>反码的表示范围与原码一致，真值0同样有两种表示形式。</p>
<h5 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h5><p>正数的补码就是原码，负数的补码是在其反码的末尾加1（需进位）。（转回原码也是同样的操作~）</p>
<p>补码的真值0只有一种表示形式。规定[x]补&#x3D;1000,0000表示-2^7。</p>
<p>若机器字长为n+1位，补码整数的表示范围为[-2^n,2^n-1]，补码小数的表示范围为[-1,1-2^(-n)]。</p>
<p>*负数补码中，最右侧的1及其右侧同原码，左侧同反码。</p>
<h5 id="移码"><a href="#移码" class="headerlink" title="移码"></a>移码</h5><p>在补码的基础上将符号位取反，但只能用于表示整数，可以很方便的比较数值大小。</p>
<p>真值0同样只有一种表示形式，表示范围和补码相同。</p>
<h3 id="2-2-2-原码补码移码的作用"><a href="#2-2-2-原码补码移码的作用" class="headerlink" title="2.2.2 原码补码移码的作用"></a>2.2.2 原码补码移码的作用</h3><p>对原码进行加减运算时，需要把负数变为正数，运算做相应的调整，否则会出错。硬件由加法器、减法器实现。</p>
<h4 id="补码——用加法代替减法"><a href="#补码——用加法代替减法" class="headerlink" title="补码——用加法代替减法"></a>补码——用加法代替减法</h4><p>原理：使用补数将减法操作转变为等价的加法，执行加法操作时，符号位可以一起参与运算。补数与原数之和即为模，节省硬件成本。</p>
<h3 id="2-2-3-移位运算"><a href="#2-2-3-移位运算" class="headerlink" title="2.2.3 移位运算"></a>2.2.3 移位运算</h3><h4 id="算术移位"><a href="#算术移位" class="headerlink" title="算术移位"></a>算术移位</h4><p>小数点前&#x2F;后移实际上改变了各个数码位的位权，可以等价地实现乘&#x2F;除法。</p>
<p>右移：相当于除法，高位补0，低位舍弃，若舍弃位不为0则会丢失精度。</p>
<p>左移：相当于乘法，低位补0，高位舍弃，若舍弃位不为0则会出现严重误差。</p>
<p>由于位数有限，有时无法用算数移位精确地等效实现乘除法。</p>
<h5 id="反码的算数移位"><a href="#反码的算数移位" class="headerlink" title="反码的算数移位"></a>反码的算数移位</h5><p>正数同上，负数左右移时补位补1。</p>
<h5 id="补码的算数移位"><a href="#补码的算数移位" class="headerlink" title="补码的算数移位"></a>补码的算数移位</h5><p>正数同上，负数右移同反码添1，左移同原码添0。</p>
<h4 id="逻辑移位"><a href="#逻辑移位" class="headerlink" title="逻辑移位"></a>逻辑移位</h4><p>左移右移都补0，移出的位舍弃，相当于是对无符号数的算数移位。</p>
<h4 id="循环移位"><a href="#循环移位" class="headerlink" title="循环移位"></a>循环移位</h4><p>移位时移出来的位回到空位中进行补位。</p>
<p>带进位位的循环左移：多了一位（CF）的循环移位。</p>
<h3 id="2-2-4-加减运算和溢出判断"><a href="#2-2-4-加减运算和溢出判断" class="headerlink" title="2.2.4 加减运算和溢出判断"></a>2.2.4 加减运算和溢出判断</h3><h4 id="原码的加法运算"><a href="#原码的加法运算" class="headerlink" title="原码的加法运算"></a>原码的加法运算</h4><p>正+正：绝对值做加法，结果为正。</p>
<p>负+负：绝对值做加法，结果为负。</p>
<p>正+负&#x2F;负+正：绝对值大的减去绝对值小的，符号与绝对值较大的数相同。</p>
<p>*正+正&amp;负+负可能溢出。</p>
<h4 id="原码的减法运算"><a href="#原码的减法运算" class="headerlink" title="原码的减法运算"></a>原码的减法运算</h4><p>将减数符号取反，转变为加法操作即可。</p>
<h4 id="补码的加减运算"><a href="#补码的加减运算" class="headerlink" title="补码的加减运算"></a>补码的加减运算</h4><p>对补码而言，无论加法还是减法最终都会转变成加法，硬件由加法器实现，符号位也参与运算。</p>
<p>*两数同号时可能由于机器字长不够导致溢出现象。</p>
<h4 id="溢出判断"><a href="#溢出判断" class="headerlink" title="溢出判断"></a>溢出判断</h4><p>上溢：正+正&#x3D;负。&amp;下溢：负+负&#x3D;正。</p>
<h5 id="判断方法"><a href="#判断方法" class="headerlink" title="判断方法"></a>判断方法</h5><p>1.使用一位符号位：</p>
<p>设A的符号为As，B的符号为Bs，运算结果的符号为Ss，则溢出逻辑表达式为V &#x3D; AsBs┐Ss+┐As┐BsSs。</p>
<p>若V &#x3D; 0，表示无溢出；若V &#x3D; 1，表示有溢出。</p>
<p>2.使用一位符号位，根据数据位进位的情况判断：</p>
<p>符号位的进位Cs和最高数值位的进位C1相反时发生溢出。</p>
<p>溢出逻辑表达式为v &#x3D; Cs ⊕ C1。若V &#x3D; 0，表示无溢出；若V &#x3D; 1，表示有溢出。</p>
<p>3.使用双符号位：</p>
<p>正数符号位为00，负数符号位为11。若最终结果符号位为01&#x2F;10则表示产生溢出。</p>
<p>记两个符号位为Ss1Ss2，则V &#x3D; Ss1⊕Ss2。若V &#x3D; 0，表示无溢出；若V &#x3D; 1，表示有溢出。</p>
<p>*双符号位补码又称模4补码，单符号位补码又称模2补码。</p>
<h4 id="符号扩展"><a href="#符号扩展" class="headerlink" title="符号扩展"></a>符号扩展</h4><h5 id="定点整数的符号扩展"><a href="#定点整数的符号扩展" class="headerlink" title="定点整数的符号扩展"></a>定点整数的符号扩展</h5><p>在原符号位和数值位<em>中间</em>补位，正数补0，负数原码补0，反、补码补1。</p>
<h5 id="定点小数的符号扩展"><a href="#定点小数的符号扩展" class="headerlink" title="定点小数的符号扩展"></a>定点小数的符号扩展</h5><p>在原符号位和数值位<em>后面</em>补位，正数补0，负数原码补0，反、补码补1。</p>
<h3 id="2-2-5-1-原码的乘法运算"><a href="#2-2-5-1-原码的乘法运算" class="headerlink" title="2.2.5-1 原码的乘法运算"></a>2.2.5-1 原码的乘法运算</h3><h4 id="实现原理"><a href="#实现原理" class="headerlink" title="实现原理"></a>实现原理</h4><p>先加法（ACC+X-&gt;ACC）再移位（逻辑右移一&#x2F;二位，高位补0），重复n次，符号位使用异或单独处理，不参与运算。</p>
<h4 id="原码一位乘法"><a href="#原码一位乘法" class="headerlink" title="原码一位乘法"></a>原码一位乘法</h4><p>设机器字长为n+1&#x3D;5位（含一位符号位）：符号单独处理，运算结果符号位&#x3D;x5⊕ y5；数值位再取绝对值进行乘法运算。</p>
<h3 id="2-2-5-2-补码的乘法运算"><a href="#2-2-5-2-补码的乘法运算" class="headerlink" title="2.2.5-2 补码的乘法运算"></a>2.2.5-2 补码的乘法运算</h3><h4 id="补码一位乘法（Booth算法）"><a href="#补码一位乘法（Booth算法）" class="headerlink" title="补码一位乘法（Booth算法）"></a>补码一位乘法（Booth算法）</h4><p>进行n轮加法、移位，每次加法的加数由当前MQ中的最低位及辅助位确定，有0&#x2F;[x]补&#x2F;[-x]补三种可能；移位则是补码的算数右移；符号位参与运算。最后还有一次加法运算。</p>
<p>由于MQ中增加了一位辅助位，总位数为n+2，故所有寄存器统一采用n+2位，使用双符号位补码进行运算。</p>
<h3 id="2-2-6-1-原码的除法运算"><a href="#2-2-6-1-原码的除法运算" class="headerlink" title="2.2.6-1 原码的除法运算"></a>2.2.6-1 原码的除法运算</h3><h4 id="恢复余数法"><a href="#恢复余数法" class="headerlink" title="恢复余数法"></a>恢复余数法</h4><p>设机器字长为五位（含一位符号位，n &#x3D; 4），符号位依旧单独处理：x5⊕ y5，数值位取绝对值进行除法运算。</p>
<p>MQ初始默认商1，若ACC - 除数得到负值则修改商为0，同时ACC加回余数。ACC、MQ整体逻辑左移，ACC高位丢弃，MQ低位补0。重复上述操作直到商达到机器字长的长度。（左移n次，上商n+1次）</p>
<h4 id="加减交替法"><a href="#加减交替法" class="headerlink" title="加减交替法"></a>加减交替法</h4><p>设余数为a，除数为b，恢复余数法最终需要得到的新余数就是2*a+b（左移再相加），若为正，则商1，让余数左移一位再<em>减去</em>除数的绝对值，得到新余数；为负则直接商0，并让余数左移一位再<em>加上</em>除数的绝对值。</p>
<p>第一步为被除数减去除数的绝对值得到新余数，之后每次根据余数的正负性来确定应该加商除数的绝对值还是减去。</p>
<p>虽然又名不恢复余数法，但若最终余数为负，还需商0并加上除数的绝对值才能得到正确余数。</p>
<h3 id="2-2-6-2-补码的除法运算"><a href="#2-2-6-2-补码的除法运算" class="headerlink" title="2.2.6-2 补码的除法运算"></a>2.2.6-2 补码的除法运算</h3><p>补码的加减交替法与原码类似，但符号位参与运算，且使用双符号位进行运算。</p>
<p>第一步看被除数与除数是否同号，若同号则被除数减去除数；异号则加上除数。之后判断余数和除数是否同号，同号则商1，余数左移一位并减去除数；若为异号则商0，余数左移一位并加上除数。上述操作重复n次（机器字长的限制）。</p>
<p>另外末尾商恒置1（精度误差不超过2^-n）。</p>
<h3 id="2-2-7-强制类型转换"><a href="#2-2-7-强制类型转换" class="headerlink" title="2.2.7 强制类型转换"></a>2.2.7 强制类型转换</h3><p>在C中，定点整数使用补码储存。</p>
<p>无符号数与有符号数：不改变数据内容，改变解释方式。</p>
<p>长整数变短整数：高位截断，保留低位。（如int-&gt;short）</p>
<p>短整数变长整数：符号扩展（负数高位添1，正数添0）。</p>
<h3 id="2-2-8-数据的存储和排列"><a href="#2-2-8-数据的存储和排列" class="headerlink" title="2.2.8 数据的存储和排列"></a>2.2.8 数据的存储和排列</h3><h4 id="大小端模式"><a href="#大小端模式" class="headerlink" title="大小端模式"></a>大小端模式</h4><p>多字节数据在内存里一定是占连续的几个字节。以四字节int为例，大端存储方式从左到右（低地址到高地址）是最高有效字节（MSB）到最低有效字节（LSB），符合人类阅读习惯，小端方式则相反，但更便于机器处理。</p>
<h4 id="边界对齐"><a href="#边界对齐" class="headerlink" title="边界对齐"></a>边界对齐</h4><p>现代计算机通常是按字节编址，即每个字节对应一个地址，通常也支持按字、半字、字节寻址。（从零开始）一个字对应四个字节，一个半字对应两个字节。则要查找某字节只需要将地址右移两位，查找半字则右移一位。（乘2&#x2F;4）</p>
<p>由于计算机每次访存只能读&#x2F;写一个字，边界对齐方式的查找效率要高于边界不对齐方式。（空间换时间）</p>
<h3 id="2-3-1-浮点数的表示"><a href="#2-3-1-浮点数的表示" class="headerlink" title="2.3.1 浮点数的表示"></a>2.3.1 浮点数的表示</h3><h4 id="定点数的局限性"><a href="#定点数的局限性" class="headerlink" title="定点数的局限性"></a>定点数的局限性</h4><p>定点数可表示的数据范围有限，但我们不能无限制地增加数据长度，故探求如何在数据位数不变的前提下扩大数据的可表示范围。</p>
<h4 id="浮点数的表示"><a href="#浮点数的表示" class="headerlink" title="浮点数的表示"></a>浮点数的表示</h4><p>将数划分为阶码和尾数，其中阶码又分为阶符和阶码的数值部分；尾数又分为数符和尾数的数值部分。阶符表示小数点应该左移还是右移（移动几位由阶码的数值部分确定），尾数数值部分越短，所表示的数的精度越低。</p>
<p>阶码通常是补码或移码表示的定点整数，尾数通常是原码或者补码表示的定点小数。</p>
<h4 id="浮点数尾数的规格化"><a href="#浮点数尾数的规格化" class="headerlink" title="浮点数尾数的规格化"></a>浮点数尾数的规格化</h4><p>在存储长度有限的情况下，尾数的最高位若是无效值零则会丧失精度。</p>
<p>使用左规的方法将其进行规格化：将尾数算术左移一位，同时阶码减一，直到尾数最高位是有效值。同理也有右规，当浮点数运算的结果尾数出现溢出的情况（双符号位为01或10）时，将尾数算数右移一位，阶码加一，直到双符号位变回00。</p>
<p>*采用双符号位，当发生溢出时可以进行挽救，更高的符号位是正确的符号位。</p>
<h4 id="规格化浮点数的特点"><a href="#规格化浮点数的特点" class="headerlink" title="规格化浮点数的特点"></a>规格化浮点数的特点</h4><h5 id="用原码表示的尾数进行规格化"><a href="#用原码表示的尾数进行规格化" class="headerlink" title="用原码表示的尾数进行规格化"></a>用原码表示的尾数进行规格化</h5><p>正数为0.1xx…x的形式，其最大值表示为0.11…1；最小值表示为0.10…0，尾数的表示范围为[1&#x2F;2，1-2^-n]。</p>
<p>负数为1.1xx…x的形式，其最大值表示为1.10…0；最小值表示为1.11…1，尾数的表示范围为[-1+2^-n，-1&#x2F;2]。</p>
<p>*规格化后的原码尾数，最高数值位一定为一。</p>
<h5 id="用补码表示的尾数进行规格化"><a href="#用补码表示的尾数进行规格化" class="headerlink" title="用补码表示的尾数进行规格化"></a>用补码表示的尾数进行规格化</h5><p>正数同原码，负数为1.0xx…x的形式，其最大值表示为1.01…1；最小值表示为1.00…0，尾数的表示范围为[-1，-1&#x2F;2-2^-n]。</p>
<p>*规格化后的补码尾数，符号位和数值位必定相反。</p>
<p>当出现正下溢或是负下溢时，将这个数近似看作0。</p>
<h3 id="2-3-2-浮点数标准-IEEE-745"><a href="#2-3-2-浮点数标准-IEEE-745" class="headerlink" title="2.3.2 浮点数标准 IEEE 745"></a>2.3.2 浮点数标准 IEEE 745</h3>
        </div>

    </div>

    

    

    

    

    

    
<nav class="article-nav">
  
    <a href="/2022/07/02/14_Memo/" id="article-nav-newer" class="article-nav-link-wrap">
      <div class="article-nav-caption">下一篇</div>
      <div class="article-nav-title">
        
          #14 备忘录
        
      </div>
    </a>
  
  
    <a href="/2022/06/06/12_C++_Multithreading/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-caption">上一篇</div>
      <div class="article-nav-title">#12 C++多线程</div>
    </a>
  
</nav>


    <section class="share">
        <div class="share-title">分享</div>
        <a class="share-item" target="_blank"
            href="https://twitter.com/share?text=#13 王道408计组听课笔记 - Function's Blog&url=http%3A%2F%2Fblog.functioneurus.com%2F2022%2F06%2F27%2F13_Note_of_Principles_of_Computer_Composition%2F">
            <box-icon type='logo' name='twitter'></box-icon>
        </a>
        <a class="share-item" target="_blank"
            href="https://www.facebook.com/sharer.php?title=#13 王道408计组听课笔记 - Function's Blog&u=http%3A%2F%2Fblog.functioneurus.com%2F2022%2F06%2F27%2F13_Note_of_Principles_of_Computer_Composition%2F">
            <box-icon name='facebook-square' type='logo' ></box-icon>
        </a>
        <!-- <a class="share-item" target="_blank"
            href="https://service.weibo.com/share/share.php?title=#13 王道408计组听课笔记 - Function's Blog&url=http://blog.functioneurus.com/2022/06/27/13_Note_of_Principles_of_Computer_Composition/&pic=">
            <div class="n-icon n-icon-weibo"></div>
        </a> -->
    </section>

</article>
















</div>
                </section>
            </section>

            
            <aside class="sidebar ">
                


<div class="widget" id="widget">
    
      
  <div class="widget-wrap">
    <div class="widget-inner">
      <div class="toc post-toc-html"></div>
    </div>
  </div>

    
      

    
      
  <div class="widget-wrap widget-tags">
    <div class="widget-title"><span>Tags</span></div>
    <div class="widget-inner">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/408/" rel="tag">408</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/C/" rel="tag">C++</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/DB/" rel="tag">DB</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Memo/" rel="tag">Memo</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E4%B9%B1%E7%BF%BB%E4%B9%A6/" rel="tag">乱翻书</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%90%8C%E4%BA%BA/" rel="tag">同人</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%BA%9F%E8%AF%9D/" rel="tag">废话</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E7%AE%97%E6%B3%95/" rel="tag">算法</a></li></ul>
    </div>
  </div>


    
      
  <div class="widget-wrap widget-recent-posts">
    <div class="widget-title"><span>Recent Posts</span></div>
    <div class="widget-inner">
      <ul>
        
          <li>
            <a href="/2023/06/02/broken_thoughts_in_23_JUNE/">碎碎念存档_JUNE</a>
          </li>
        
          <li>
            <a href="/2023/05/04/broken_thoughts_in_23_MAY/">碎碎念存档_MAY</a>
          </li>
        
          <li>
            <a href="/2023/04/01/broken_thoughts_in_APR/">碎碎念存档_APR</a>
          </li>
        
          <li>
            <a href="/2023/03/26/16_Database_notes/">#16 数据库看书笔记</a>
          </li>
        
          <li>
            <a href="/2023/03/01/broken_thoughts_in_MAR/">碎碎念存档_MAR</a>
          </li>
        
      </ul>
    </div>
  </div>

    
      
  <div class="widget-wrap widget-archive">
    <div class="widget-title"><span>Archive</span></div>
    <div class="widget-inner">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/">2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/">2022</a></li></ul>
    </div>
  </div>


    
</div>

<div id="backtop"><i class="icon icon-arrow-up"></i></div>
            </aside>
            
        </div>
    </div>

    <footer class="footer">
    <div class="footer-wave">
        <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 320"><path fill="#3c4859" fill-opacity="1" d="M0,160L60,181.3C120,203,240,245,360,240C480,235,600,181,720,186.7C840,192,960,256,1080,261.3C1200,267,1320,213,1380,186.7L1440,160L1440,320L1380,320C1320,320,1200,320,1080,320C960,320,840,320,720,320C600,320,480,320,360,320C240,320,120,320,60,320L0,320Z"></path></svg>
    </div>

    <!-- Please do not remove this -->
    <!-- 开源不易，请勿删除 -->
    <div class="footer-wrap">
        <div class="footer-inner"> 
            Function&#39;s Blog &copy; 2023<br>
            Powered By Hexo · Theme By <a href="https://linhong.me/" target="_blank">Aomori</a> · <a href="https://github.com/lh1me/hexo-theme-aomori" target="_blank">Github</a>
        </div>
    </div>

</footer>






<script src="/dist/build.js?1651727875408.js"></script>


<script src="/dist/custom.js?1651727875408.js"></script>













</body>

</html>